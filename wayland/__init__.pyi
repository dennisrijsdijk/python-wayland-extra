# DO NOT EDIT this file, it is automatically generated.
# 
# This file is only used as a code completion helper
# for editors, it is not used at runtime.

from typing import TypeAlias, Annotated
new_id: TypeAlias = int
object: TypeAlias = int
uint: TypeAlias = int
string: TypeAlias = str
fd: TypeAlias = int
array: TypeAlias = list
fixed: TypeAlias = float

class wl_display:
    object_id = 0

    # opcode 0
    @staticmethod
    def sync() -> wl_callback:
        """
        asynchronous roundtrip
        
        The sync request asks the server to emit the 'done' event
        on the returned wl_callback object.  Since requests are
        handled in-order and events are delivered in-order, this can
        be used as a barrier to ensure all previous requests and the
        resulting events have been handled.
        
        The object returned by this request will be destroyed by the
        compositor after the callback is fired and as such the client must not
        attempt to use it after that point.
        
        The callback_data passed in the callback is undefined and should be ignored.
        """
        ...

    # opcode 1
    @staticmethod
    def get_registry() -> wl_registry:
        """
        get global registry object
        
        This request creates a registry object that allows the client
        to list and bind the global objects available from the
        compositor.
        
        It should be noted that the server side resources consumed in
        response to a get_registry request can only be released when the
        client disconnects, not when the client side proxy is destroyed.
        Therefore, clients should invoke get_registry as infrequently as
        possible to avoid wasting memory.
        """
        ...

    class events:
        # opcode 0
        @staticmethod
        def error(object_id: object, code: uint, message: string) -> None:
            """
            fatal error event
            
            The error event is sent out when a fatal (non-recoverable)
            error has occurred.  The object_id argument is the object
            where the error occurred, most often in response to a request
            to that object.  The code identifies the error and is defined
            by the object interface.  As such, each interface defines its
            own set of error codes.  The message is a brief description
            of the error, for (debugging) convenience.
            """
            ...

        # opcode 1
        @staticmethod
        def delete_id(id: uint) -> None:
            """
            acknowledge object ID deletion
            
            This event is used internally by the object ID management
            logic. When a client deletes an object that it had created,
            the server will send this event to acknowledge that it has
            seen the delete request. When the client receives this event,
            it will know that it can safely reuse the object ID.
            """
            ...

class wl_registry:
    object_id = 0

    # opcode 0
    @staticmethod
    def bind(name: uint, interface: string, version: uint, id: new_id) -> None:
        """
        bind an object to the display
        
        Binds a new, client-created object to the server using the
        specified name as the identifier.
        """
        ...

    class events:
        # opcode 0
        @staticmethod
        def global_(name: uint, interface: string, version: uint) -> None:
            """
            announce global object
            
            Notify the client of global objects.
            
            The event notifies the client that a global object with
            the given name is now available, and it implements the
            given version of the given interface.
            """
            ...

        # opcode 1
        @staticmethod
        def global_remove(name: uint) -> None:
            """
            announce removal of global object
            
            Notify the client of removed global objects.
            
            This event notifies the client that the global identified
            by name is no longer available.  If the client bound to
            the global using the bind request, the client should now
            destroy that object.
            
            The object remains valid and requests to the object will be
            ignored until the client destroys it, to avoid races between
            the global going away and a client sending a request to it.
            """
            ...

class wl_compositor:
    object_id = 0

    # opcode 0
    @staticmethod
    def create_surface() -> wl_surface:
        """
        create new surface
        
        Ask the compositor to create a new surface.
        """
        ...

    # opcode 1
    @staticmethod
    def create_region() -> wl_region:
        """
        create new region
        
        Ask the compositor to create a new region.
        """
        ...

class wl_shm_pool:
    object_id = 0

    # opcode 0
    @staticmethod
    def create_buffer(offset: int, width: int, height: int, stride: int, format: uint) -> wl_buffer:
        """
        create a buffer from the pool
        
        Create a wl_buffer object from the pool.
        
        The buffer is created offset bytes into the pool and has
        width and height as specified.  The stride argument specifies
        the number of bytes from the beginning of one row to the beginning
        of the next.  The format is the pixel format of the buffer and
        must be one of those advertised through the wl_shm.format event.
        
        A buffer will keep a reference to the pool it was created from
        so it is valid to destroy the pool immediately after creating
        a buffer from it.
        """
        ...

    # opcode 1
    @staticmethod
    def destroy() -> None:
        """
        destroy the pool
        
        Destroy the shared memory pool.
        
        The mmapped memory will be released when all
        buffers that have been created from this pool
        are gone.
        """
        ...

    # opcode 2
    @staticmethod
    def resize(size: int) -> None:
        """
        change the size of the pool mapping
        
        This request will cause the server to remap the backing memory
        for the pool from the file descriptor passed when the pool was
        created, but using the new size.  This request can only be
        used to make the pool bigger.
        
        This request only changes the amount of bytes that are mmapped
        by the server and does not touch the file corresponding to the
        file descriptor passed at creation time. It is the client's
        responsibility to ensure that the file is at least as big as
        the new pool size.
        """
        ...

class wl_shm:
    object_id = 0

    # opcode 0
    @staticmethod
    def create_pool(fd: fd, size: int) -> wl_shm_pool:
        """
        create a shm pool
        
        Create a new wl_shm_pool object.
        
        The pool can be used to create shared memory based buffer
        objects.  The server will mmap size bytes of the passed file
        descriptor, to use as backing memory for the pool.
        """
        ...

    # opcode 1
    @staticmethod
    def release() -> None:
        """
        release the shm object
        
        Using this request a client can tell the server that it is not going to
        use the shm object anymore.
        
        Objects created via this interface remain unaffected.
        """
        ...

    class events:
        # opcode 0
        @staticmethod
        def format(format: uint) -> None:
            """
            pixel format description
            
            Informs the client about a valid pixel format that
            can be used for buffers. Known formats include
            argb8888 and xrgb8888.
            """
            ...

class wl_buffer:
    object_id = 0

    # opcode 0
    @staticmethod
    def destroy() -> None:
        """
        destroy a buffer
        
        Destroy a buffer. If and how you need to release the backing
        storage is defined by the buffer factory interface.
        
        For possible side-effects to a surface, see wl_surface.attach.
        """
        ...

    class events:
        # opcode 0
        @staticmethod
        def release() -> None:
            """
            compositor releases buffer
            
            Sent when this wl_buffer is no longer used by the compositor.
            The client is now free to reuse or destroy this buffer and its
            backing storage.
            
            If a client receives a release event before the frame callback
            requested in the same wl_surface.commit that attaches this
            wl_buffer to a surface, then the client is immediately free to
            reuse the buffer and its backing storage, and does not need a
            second buffer for the next surface content update. Typically
            this is possible, when the compositor maintains a copy of the
            wl_surface contents, e.g. as a GL texture. This is an important
            optimization for GL(ES) compositors with wl_shm clients.
            """
            ...

class wl_data_offer:
    object_id = 0

    # opcode 0
    @staticmethod
    def accept(serial: uint, mime_type: string) -> None:
        """
        accept one of the offered mime types
        
        Indicate that the client can accept the given mime type, or
        NULL for not accepted.
        
        For objects of version 2 or older, this request is used by the
        client to give feedback whether the client can receive the given
        mime type, or NULL if none is accepted; the feedback does not
        determine whether the drag-and-drop operation succeeds or not.
        
        For objects of version 3 or newer, this request determines the
        final result of the drag-and-drop operation. If the end result
        is that no mime types were accepted, the drag-and-drop operation
        will be cancelled and the corresponding drag source will receive
        wl_data_source.cancelled. Clients may still use this event in
        conjunction with wl_data_source.action for feedback.
        """
        ...

    # opcode 1
    @staticmethod
    def receive(mime_type: string, fd: fd) -> None:
        """
        request that the data is transferred
        
        To transfer the offered data, the client issues this request
        and indicates the mime type it wants to receive.  The transfer
        happens through the passed file descriptor (typically created
        with the pipe system call).  The source client writes the data
        in the mime type representation requested and then closes the
        file descriptor.
        
        The receiving client reads from the read end of the pipe until
        EOF and then closes its end, at which point the transfer is
        complete.
        
        This request may happen multiple times for different mime types,
        both before and after wl_data_device.drop. Drag-and-drop destination
        clients may preemptively fetch data or examine it more closely to
        determine acceptance.
        """
        ...

    # opcode 2
    @staticmethod
    def destroy() -> None:
        """
        destroy data offer
        
        Destroy the data offer.
        """
        ...

    # opcode 3
    @staticmethod
    def finish() -> None:
        """
        the offer will no longer be used
        
        Notifies the compositor that the drag destination successfully
        finished the drag-and-drop operation.
        
        Upon receiving this request, the compositor will emit
        wl_data_source.dnd_finished on the drag source client.
        
        It is a client error to perform other requests than
        wl_data_offer.destroy after this one. It is also an error to perform
        this request after a NULL mime type has been set in
        wl_data_offer.accept or no action was received through
        wl_data_offer.action.
        
        If wl_data_offer.finish request is received for a non drag and drop
        operation, the invalid_finish protocol error is raised.
        """
        ...

    # opcode 4
    @staticmethod
    def set_actions(dnd_actions: uint, preferred_action: uint) -> None:
        """
        set the available/preferred drag-and-drop actions
        
        Sets the actions that the destination side client supports for
        this operation. This request may trigger the emission of
        wl_data_source.action and wl_data_offer.action events if the compositor
        needs to change the selected action.
        
        This request can be called multiple times throughout the
        drag-and-drop operation, typically in response to wl_data_device.enter
        or wl_data_device.motion events.
        
        This request determines the final result of the drag-and-drop
        operation. If the end result is that no action is accepted,
        the drag source will receive wl_data_source.cancelled.
        
        The dnd_actions argument must contain only values expressed in the
        wl_data_device_manager.dnd_actions enum, and the preferred_action
        argument must only contain one of those values set, otherwise it
        will result in a protocol error.
        
        While managing an "ask" action, the destination drag-and-drop client
        may perform further wl_data_offer.receive requests, and is expected
        to perform one last wl_data_offer.set_actions request with a preferred
        action other than "ask" (and optionally wl_data_offer.accept) before
        requesting wl_data_offer.finish, in order to convey the action selected
        by the user. If the preferred action is not in the
        wl_data_offer.source_actions mask, an error will be raised.
        
        If the "ask" action is dismissed (e.g. user cancellation), the client
        is expected to perform wl_data_offer.destroy right away.
        
        This request can only be made on drag-and-drop offers, a protocol error
        will be raised otherwise.
        """
        ...

    class events:
        # opcode 0
        @staticmethod
        def offer(mime_type: string) -> None:
            """
            advertise offered mime type
            
            Sent immediately after creating the wl_data_offer object.  One
            event per offered mime type.
            """
            ...

        # opcode 1
        @staticmethod
        def source_actions(source_actions: uint) -> None:
            """
            notify the source-side available actions
            
            This event indicates the actions offered by the data source. It
            will be sent immediately after creating the wl_data_offer object,
            or anytime the source side changes its offered actions through
            wl_data_source.set_actions.
            """
            ...

        # opcode 2
        @staticmethod
        def action(dnd_action: uint) -> None:
            """
            notify the selected action
            
            This event indicates the action selected by the compositor after
            matching the source/destination side actions. Only one action (or
            none) will be offered here.
            
            This event can be emitted multiple times during the drag-and-drop
            operation in response to destination side action changes through
            wl_data_offer.set_actions.
            
            This event will no longer be emitted after wl_data_device.drop
            happened on the drag-and-drop destination, the client must
            honor the last action received, or the last preferred one set
            through wl_data_offer.set_actions when handling an "ask" action.
            
            Compositors may also change the selected action on the fly, mainly
            in response to keyboard modifier changes during the drag-and-drop
            operation.
            
            The most recent action received is always the valid one. Prior to
            receiving wl_data_device.drop, the chosen action may change (e.g.
            due to keyboard modifiers being pressed). At the time of receiving
            wl_data_device.drop the drag-and-drop destination must honor the
            last action received.
            
            Action changes may still happen after wl_data_device.drop,
            especially on "ask" actions, where the drag-and-drop destination
            may choose another action afterwards. Action changes happening
            at this stage are always the result of inter-client negotiation, the
            compositor shall no longer be able to induce a different action.
            
            Upon "ask" actions, it is expected that the drag-and-drop destination
            may potentially choose a different action and/or mime type,
            based on wl_data_offer.source_actions and finally chosen by the
            user (e.g. popping up a menu with the available options). The
            final wl_data_offer.set_actions and wl_data_offer.accept requests
            must happen before the call to wl_data_offer.finish.
            """
            ...

class wl_data_source:
    object_id = 0

    # opcode 0
    @staticmethod
    def offer(mime_type: string) -> None:
        """
        add an offered mime type
        
        This request adds a mime type to the set of mime types
        advertised to targets.  Can be called several times to offer
        multiple types.
        """
        ...

    # opcode 1
    @staticmethod
    def destroy() -> None:
        """
        destroy the data source
        
        Destroy the data source.
        """
        ...

    # opcode 2
    @staticmethod
    def set_actions(dnd_actions: uint) -> None:
        """
        set the available drag-and-drop actions
        
        Sets the actions that the source side client supports for this
        operation. This request may trigger wl_data_source.action and
        wl_data_offer.action events if the compositor needs to change the
        selected action.
        
        The dnd_actions argument must contain only values expressed in the
        wl_data_device_manager.dnd_actions enum, otherwise it will result
        in a protocol error.
        
        This request must be made once only, and can only be made on sources
        used in drag-and-drop, so it must be performed before
        wl_data_device.start_drag. Attempting to use the source other than
        for drag-and-drop will raise a protocol error.
        """
        ...

    class events:
        # opcode 0
        @staticmethod
        def target(mime_type: string) -> None:
            """
            a target accepts an offered mime type
            
            Sent when a target accepts pointer_focus or motion events.  If
            a target does not accept any of the offered types, type is NULL.
            
            Used for feedback during drag-and-drop.
            """
            ...

        # opcode 1
        @staticmethod
        def send(mime_type: string, fd: fd) -> None:
            """
            send the data
            
            Request for data from the client.  Send the data as the
            specified mime type over the passed file descriptor, then
            close it.
            """
            ...

        # opcode 2
        @staticmethod
        def cancelled() -> None:
            """
            selection was cancelled
            
            This data source is no longer valid. There are several reasons why
            this could happen:
            
            - The data source has been replaced by another data source.
            - The drag-and-drop operation was performed, but the drop destination
            did not accept any of the mime types offered through
            wl_data_source.target.
            - The drag-and-drop operation was performed, but the drop destination
            did not select any of the actions present in the mask offered through
            wl_data_source.action.
            - The drag-and-drop operation was performed but didn't happen over a
            surface.
            - The compositor cancelled the drag-and-drop operation (e.g. compositor
            dependent timeouts to avoid stale drag-and-drop transfers).
            
            The client should clean up and destroy this data source.
            
            For objects of version 2 or older, wl_data_source.cancelled will
            only be emitted if the data source was replaced by another data
            source.
            """
            ...

        # opcode 3
        @staticmethod
        def dnd_drop_performed() -> None:
            """
            the drag-and-drop operation physically finished
            
            The user performed the drop action. This event does not indicate
            acceptance, wl_data_source.cancelled may still be emitted afterwards
            if the drop destination does not accept any mime type.
            
            However, this event might however not be received if the compositor
            cancelled the drag-and-drop operation before this event could happen.
            
            Note that the data_source may still be used in the future and should
            not be destroyed here.
            """
            ...

        # opcode 4
        @staticmethod
        def dnd_finished() -> None:
            """
            the drag-and-drop operation concluded
            
            The drop destination finished interoperating with this data
            source, so the client is now free to destroy this data source and
            free all associated data.
            
            If the action used to perform the operation was "move", the
            source can now delete the transferred data.
            """
            ...

        # opcode 5
        @staticmethod
        def action(dnd_action: uint) -> None:
            """
            notify the selected action
            
            This event indicates the action selected by the compositor after
            matching the source/destination side actions. Only one action (or
            none) will be offered here.
            
            This event can be emitted multiple times during the drag-and-drop
            operation, mainly in response to destination side changes through
            wl_data_offer.set_actions, and as the data device enters/leaves
            surfaces.
            
            It is only possible to receive this event after
            wl_data_source.dnd_drop_performed if the drag-and-drop operation
            ended in an "ask" action, in which case the final wl_data_source.action
            event will happen immediately before wl_data_source.dnd_finished.
            
            Compositors may also change the selected action on the fly, mainly
            in response to keyboard modifier changes during the drag-and-drop
            operation.
            
            The most recent action received is always the valid one. The chosen
            action may change alongside negotiation (e.g. an "ask" action can turn
            into a "move" operation), so the effects of the final action must
            always be applied in wl_data_offer.dnd_finished.
            
            Clients can trigger cursor surface changes from this point, so
            they reflect the current action.
            """
            ...

class wl_data_device:
    object_id = 0

    # opcode 0
    @staticmethod
    def start_drag(source: object, origin: object, icon: object, serial: uint) -> None:
        """
        start drag-and-drop operation
        
        This request asks the compositor to start a drag-and-drop
        operation on behalf of the client.
        
        The source argument is the data source that provides the data
        for the eventual data transfer. If source is NULL, enter, leave
        and motion events are sent only to the client that initiated the
        drag and the client is expected to handle the data passing
        internally. If source is destroyed, the drag-and-drop session will be
        cancelled.
        
        The origin surface is the surface where the drag originates and
        the client must have an active implicit grab that matches the
        serial.
        
        The icon surface is an optional (can be NULL) surface that
        provides an icon to be moved around with the cursor.  Initially,
        the top-left corner of the icon surface is placed at the cursor
        hotspot, but subsequent wl_surface.offset requests can move the
        relative position. Attach requests must be confirmed with
        wl_surface.commit as usual. The icon surface is given the role of
        a drag-and-drop icon. If the icon surface already has another role,
        it raises a protocol error.
        
        The input region is ignored for wl_surfaces with the role of a
        drag-and-drop icon.
        
        The given source may not be used in any further set_selection or
        start_drag requests. Attempting to reuse a previously-used source
        may send a used_source error.
        """
        ...

    # opcode 1
    @staticmethod
    def set_selection(source: object, serial: uint) -> None:
        """
        copy data to the selection
        
        This request asks the compositor to set the selection
        to the data from the source on behalf of the client.
        
        To unset the selection, set the source to NULL.
        
        The given source may not be used in any further set_selection or
        start_drag requests. Attempting to reuse a previously-used source
        may send a used_source error.
        """
        ...

    # opcode 2
    @staticmethod
    def release() -> None:
        """
        destroy data device
        
        This request destroys the data device.
        """
        ...

    class events:
        # opcode 0
        @staticmethod
        def data_offer(id: wl_data_offer) -> None:
            """
            introduce a new wl_data_offer
            
            The data_offer event introduces a new wl_data_offer object,
            which will subsequently be used in either the
            data_device.enter event (for drag-and-drop) or the
            data_device.selection event (for selections).  Immediately
            following the data_device.data_offer event, the new data_offer
            object will send out data_offer.offer events to describe the
            mime types it offers.
            """
            ...

        # opcode 1
        @staticmethod
        def enter(serial: uint, surface: object, x: fixed, y: fixed, id: object) -> None:
            """
            initiate drag-and-drop session
            
            This event is sent when an active drag-and-drop pointer enters
            a surface owned by the client.  The position of the pointer at
            enter time is provided by the x and y arguments, in surface-local
            coordinates.
            """
            ...

        # opcode 2
        @staticmethod
        def leave() -> None:
            """
            end drag-and-drop session
            
            This event is sent when the drag-and-drop pointer leaves the
            surface and the session ends.  The client must destroy the
            wl_data_offer introduced at enter time at this point.
            """
            ...

        # opcode 3
        @staticmethod
        def motion(time: uint, x: fixed, y: fixed) -> None:
            """
            drag-and-drop session motion
            
            This event is sent when the drag-and-drop pointer moves within
            the currently focused surface. The new position of the pointer
            is provided by the x and y arguments, in surface-local
            coordinates.
            """
            ...

        # opcode 4
        @staticmethod
        def drop() -> None:
            """
            end drag-and-drop session successfully
            
            The event is sent when a drag-and-drop operation is ended
            because the implicit grab is removed.
            
            The drag-and-drop destination is expected to honor the last action
            received through wl_data_offer.action, if the resulting action is
            "copy" or "move", the destination can still perform
            wl_data_offer.receive requests, and is expected to end all
            transfers with a wl_data_offer.finish request.
            
            If the resulting action is "ask", the action will not be considered
            final. The drag-and-drop destination is expected to perform one last
            wl_data_offer.set_actions request, or wl_data_offer.destroy in order
            to cancel the operation.
            """
            ...

        # opcode 5
        @staticmethod
        def selection(id: object) -> None:
            """
            advertise new selection
            
            The selection event is sent out to notify the client of a new
            wl_data_offer for the selection for this device.  The
            data_device.data_offer and the data_offer.offer events are
            sent out immediately before this event to introduce the data
            offer object.  The selection event is sent to a client
            immediately before receiving keyboard focus and when a new
            selection is set while the client has keyboard focus.  The
            data_offer is valid until a new data_offer or NULL is received
            or until the client loses keyboard focus.  Switching surface with
            keyboard focus within the same client doesn't mean a new selection
            will be sent.  The client must destroy the previous selection
            data_offer, if any, upon receiving this event.
            """
            ...

class wl_data_device_manager:
    object_id = 0

    # opcode 0
    @staticmethod
    def create_data_source() -> wl_data_source:
        """
        create a new data source
        
        Create a new data source.
        """
        ...

    # opcode 1
    @staticmethod
    def get_data_device(seat: object) -> wl_data_device:
        """
        create a new data device
        
        Create a new data device for a given seat.
        """
        ...

class wl_shell:
    object_id = 0

    # opcode 0
    @staticmethod
    def get_shell_surface(surface: object) -> wl_shell_surface:
        """
        create a shell surface from a surface
        
        Create a shell surface for an existing surface. This gives
        the wl_surface the role of a shell surface. If the wl_surface
        already has another role, it raises a protocol error.
        
        Only one shell surface can be associated with a given surface.
        """
        ...

class wl_shell_surface:
    object_id = 0

    # opcode 0
    @staticmethod
    def pong(serial: uint) -> None:
        """
        respond to a ping event
        
        A client must respond to a ping event with a pong request or
        the client may be deemed unresponsive.
        """
        ...

    # opcode 1
    @staticmethod
    def move(seat: object, serial: uint) -> None:
        """
        start an interactive move
        
        Start a pointer-driven move of the surface.
        
        This request must be used in response to a button press event.
        The server may ignore move requests depending on the state of
        the surface (e.g. fullscreen or maximized).
        """
        ...

    # opcode 2
    @staticmethod
    def resize(seat: object, serial: uint, edges: uint) -> None:
        """
        start an interactive resize
        
        Start a pointer-driven resizing of the surface.
        
        This request must be used in response to a button press event.
        The server may ignore resize requests depending on the state of
        the surface (e.g. fullscreen or maximized).
        """
        ...

    # opcode 3
    @staticmethod
    def set_toplevel() -> None:
        """
        make the surface a toplevel surface
        
        Map the surface as a toplevel surface.
        
        A toplevel surface is not fullscreen, maximized or transient.
        """
        ...

    # opcode 4
    @staticmethod
    def set_transient(parent: object, x: int, y: int, flags: uint) -> None:
        """
        make the surface a transient surface
        
        Map the surface relative to an existing surface.
        
        The x and y arguments specify the location of the upper left
        corner of the surface relative to the upper left corner of the
        parent surface, in surface-local coordinates.
        
        The flags argument controls details of the transient behaviour.
        """
        ...

    # opcode 5
    @staticmethod
    def set_fullscreen(method: uint, framerate: uint, output: object) -> None:
        """
        make the surface a fullscreen surface
        
        Map the surface as a fullscreen surface.
        
        If an output parameter is given then the surface will be made
        fullscreen on that output. If the client does not specify the
        output then the compositor will apply its policy - usually
        choosing the output on which the surface has the biggest surface
        area.
        
        The client may specify a method to resolve a size conflict
        between the output size and the surface size - this is provided
        through the method parameter.
        
        The framerate parameter is used only when the method is set
        to "driver", to indicate the preferred framerate. A value of 0
        indicates that the client does not care about framerate.  The
        framerate is specified in mHz, that is framerate of 60000 is 60Hz.
        
        A method of "scale" or "driver" implies a scaling operation of
        the surface, either via a direct scaling operation or a change of
        the output mode. This will override any kind of output scaling, so
        that mapping a surface with a buffer size equal to the mode can
        fill the screen independent of buffer_scale.
        
        A method of "fill" means we don't scale up the buffer, however
        any output scale is applied. This means that you may run into
        an edge case where the application maps a buffer with the same
        size of the output mode but buffer_scale 1 (thus making a
        surface larger than the output). In this case it is allowed to
        downscale the results to fit the screen.
        
        The compositor must reply to this request with a configure event
        with the dimensions for the output on which the surface will
        be made fullscreen.
        """
        ...

    # opcode 6
    @staticmethod
    def set_popup(seat: object, serial: uint, parent: object, x: int, y: int, flags: uint) -> None:
        """
        make the surface a popup surface
        
        Map the surface as a popup.
        
        A popup surface is a transient surface with an added pointer
        grab.
        
        An existing implicit grab will be changed to owner-events mode,
        and the popup grab will continue after the implicit grab ends
        (i.e. releasing the mouse button does not cause the popup to
        be unmapped).
        
        The popup grab continues until the window is destroyed or a
        mouse button is pressed in any other client's window. A click
        in any of the client's surfaces is reported as normal, however,
        clicks in other clients' surfaces will be discarded and trigger
        the callback.
        
        The x and y arguments specify the location of the upper left
        corner of the surface relative to the upper left corner of the
        parent surface, in surface-local coordinates.
        """
        ...

    # opcode 7
    @staticmethod
    def set_maximized(output: object) -> None:
        """
        make the surface a maximized surface
        
        Map the surface as a maximized surface.
        
        If an output parameter is given then the surface will be
        maximized on that output. If the client does not specify the
        output then the compositor will apply its policy - usually
        choosing the output on which the surface has the biggest surface
        area.
        
        The compositor will reply with a configure event telling
        the expected new surface size. The operation is completed
        on the next buffer attach to this surface.
        
        A maximized surface typically fills the entire output it is
        bound to, except for desktop elements such as panels. This is
        the main difference between a maximized shell surface and a
        fullscreen shell surface.
        
        The details depend on the compositor implementation.
        """
        ...

    # opcode 8
    @staticmethod
    def set_title(title: string) -> None:
        """
        set surface title
        
        Set a short title for the surface.
        
        This string may be used to identify the surface in a task bar,
        window list, or other user interface elements provided by the
        compositor.
        
        The string must be encoded in UTF-8.
        """
        ...

    # opcode 9
    @staticmethod
    def set_class(class_: string) -> None:
        """
        set surface class
        
        Set a class for the surface.
        
        The surface class identifies the general class of applications
        to which the surface belongs. A common convention is to use the
        file name (or the full path if it is a non-standard location) of
        the application's .desktop file as the class.
        """
        ...

    class events:
        # opcode 0
        @staticmethod
        def ping(serial: uint) -> None:
            """
            ping client
            
            Ping a client to check if it is receiving events and sending
            requests. A client is expected to reply with a pong request.
            """
            ...

        # opcode 1
        @staticmethod
        def configure(edges: uint, width: int, height: int) -> None:
            """
            suggest resize
            
            The configure event asks the client to resize its surface.
            
            The size is a hint, in the sense that the client is free to
            ignore it if it doesn't resize, pick a smaller size (to
            satisfy aspect ratio or resize in steps of NxM pixels).
            
            The edges parameter provides a hint about how the surface
            was resized. The client may use this information to decide
            how to adjust its content to the new size (e.g. a scrolling
            area might adjust its content position to leave the viewable
            content unmoved).
            
            The client is free to dismiss all but the last configure
            event it received.
            
            The width and height arguments specify the size of the window
            in surface-local coordinates.
            """
            ...

        # opcode 2
        @staticmethod
        def popup_done() -> None:
            """
            popup interaction is done
            
            The popup_done event is sent out when a popup grab is broken,
            that is, when the user clicks a surface that doesn't belong
            to the client owning the popup surface.
            """
            ...

class wl_surface:
    object_id = 0

    # opcode 0
    @staticmethod
    def destroy() -> None:
        """
        delete surface
        
        Deletes the surface and invalidates its object ID.
        """
        ...

    # opcode 1
    @staticmethod
    def attach(buffer: object, x: int, y: int) -> None:
        """
        set the surface contents
        
        Set a buffer as the content of this surface.
        
        The new size of the surface is calculated based on the buffer
        size transformed by the inverse buffer_transform and the
        inverse buffer_scale. This means that at commit time the supplied
        buffer size must be an integer multiple of the buffer_scale. If
        that's not the case, an invalid_size error is sent.
        
        The x and y arguments specify the location of the new pending
        buffer's upper left corner, relative to the current buffer's upper
        left corner, in surface-local coordinates. In other words, the
        x and y, combined with the new surface size define in which
        directions the surface's size changes. Setting anything other than 0
        as x and y arguments is discouraged, and should instead be replaced
        with using the separate wl_surface.offset request.
        
        When the bound wl_surface version is 5 or higher, passing any
        non-zero x or y is a protocol violation, and will result in an
        'invalid_offset' error being raised. The x and y arguments are ignored
        and do not change the pending state. To achieve equivalent semantics,
        use wl_surface.offset.
        
        Surface contents are double-buffered state, see wl_surface.commit.
        
        The initial surface contents are void; there is no content.
        wl_surface.attach assigns the given wl_buffer as the pending
        wl_buffer. wl_surface.commit makes the pending wl_buffer the new
        surface contents, and the size of the surface becomes the size
        calculated from the wl_buffer, as described above. After commit,
        there is no pending buffer until the next attach.
        
        Committing a pending wl_buffer allows the compositor to read the
        pixels in the wl_buffer. The compositor may access the pixels at
        any time after the wl_surface.commit request. When the compositor
        will not access the pixels anymore, it will send the
        wl_buffer.release event. Only after receiving wl_buffer.release,
        the client may reuse the wl_buffer. A wl_buffer that has been
        attached and then replaced by another attach instead of committed
        will not receive a release event, and is not used by the
        compositor.
        
        If a pending wl_buffer has been committed to more than one wl_surface,
        the delivery of wl_buffer.release events becomes undefined. A well
        behaved client should not rely on wl_buffer.release events in this
        case. Alternatively, a client could create multiple wl_buffer objects
        from the same backing storage or use wp_linux_buffer_release.
        
        Destroying the wl_buffer after wl_buffer.release does not change
        the surface contents. Destroying the wl_buffer before wl_buffer.release
        is allowed as long as the underlying buffer storage isn't re-used (this
        can happen e.g. on client process termination). However, if the client
        destroys the wl_buffer before receiving the wl_buffer.release event and
        mutates the underlying buffer storage, the surface contents become
        undefined immediately.
        
        If wl_surface.attach is sent with a NULL wl_buffer, the
        following wl_surface.commit will remove the surface content.
        
        If a pending wl_buffer has been destroyed, the result is not specified.
        Many compositors are known to remove the surface content on the following
        wl_surface.commit, but this behaviour is not universal. Clients seeking to
        maximise compatibility should not destroy pending buffers and should
        ensure that they explicitly remove content from surfaces, even after
        destroying buffers.
        """
        ...

    # opcode 2
    @staticmethod
    def damage(x: int, y: int, width: int, height: int) -> None:
        """
        mark part of the surface damaged
        
        This request is used to describe the regions where the pending
        buffer is different from the current surface contents, and where
        the surface therefore needs to be repainted. The compositor
        ignores the parts of the damage that fall outside of the surface.
        
        Damage is double-buffered state, see wl_surface.commit.
        
        The damage rectangle is specified in surface-local coordinates,
        where x and y specify the upper left corner of the damage rectangle.
        
        The initial value for pending damage is empty: no damage.
        wl_surface.damage adds pending damage: the new pending damage
        is the union of old pending damage and the given rectangle.
        
        wl_surface.commit assigns pending damage as the current damage,
        and clears pending damage. The server will clear the current
        damage as it repaints the surface.
        
        Note! New clients should not use this request. Instead damage can be
        posted with wl_surface.damage_buffer which uses buffer coordinates
        instead of surface coordinates.
        """
        ...

    # opcode 3
    @staticmethod
    def frame() -> wl_callback:
        """
        request a frame throttling hint
        
        Request a notification when it is a good time to start drawing a new
        frame, by creating a frame callback. This is useful for throttling
        redrawing operations, and driving animations.
        
        When a client is animating on a wl_surface, it can use the 'frame'
        request to get notified when it is a good time to draw and commit the
        next frame of animation. If the client commits an update earlier than
        that, it is likely that some updates will not make it to the display,
        and the client is wasting resources by drawing too often.
        
        The frame request will take effect on the next wl_surface.commit.
        The notification will only be posted for one frame unless
        requested again. For a wl_surface, the notifications are posted in
        the order the frame requests were committed.
        
        The server must send the notifications so that a client
        will not send excessive updates, while still allowing
        the highest possible update rate for clients that wait for the reply
        before drawing again. The server should give some time for the client
        to draw and commit after sending the frame callback events to let it
        hit the next output refresh.
        
        A server should avoid signaling the frame callbacks if the
        surface is not visible in any way, e.g. the surface is off-screen,
        or completely obscured by other opaque surfaces.
        
        The object returned by this request will be destroyed by the
        compositor after the callback is fired and as such the client must not
        attempt to use it after that point.
        
        The callback_data passed in the callback is the current time, in
        milliseconds, with an undefined base.
        """
        ...

    # opcode 4
    @staticmethod
    def set_opaque_region(region: object) -> None:
        """
        set opaque region
        
        This request sets the region of the surface that contains
        opaque content.
        
        The opaque region is an optimization hint for the compositor
        that lets it optimize the redrawing of content behind opaque
        regions.  Setting an opaque region is not required for correct
        behaviour, but marking transparent content as opaque will result
        in repaint artifacts.
        
        The opaque region is specified in surface-local coordinates.
        
        The compositor ignores the parts of the opaque region that fall
        outside of the surface.
        
        Opaque region is double-buffered state, see wl_surface.commit.
        
        wl_surface.set_opaque_region changes the pending opaque region.
        wl_surface.commit copies the pending region to the current region.
        Otherwise, the pending and current regions are never changed.
        
        The initial value for an opaque region is empty. Setting the pending
        opaque region has copy semantics, and the wl_region object can be
        destroyed immediately. A NULL wl_region causes the pending opaque
        region to be set to empty.
        """
        ...

    # opcode 5
    @staticmethod
    def set_input_region(region: object) -> None:
        """
        set input region
        
        This request sets the region of the surface that can receive
        pointer and touch events.
        
        Input events happening outside of this region will try the next
        surface in the server surface stack. The compositor ignores the
        parts of the input region that fall outside of the surface.
        
        The input region is specified in surface-local coordinates.
        
        Input region is double-buffered state, see wl_surface.commit.
        
        wl_surface.set_input_region changes the pending input region.
        wl_surface.commit copies the pending region to the current region.
        Otherwise the pending and current regions are never changed,
        except cursor and icon surfaces are special cases, see
        wl_pointer.set_cursor and wl_data_device.start_drag.
        
        The initial value for an input region is infinite. That means the
        whole surface will accept input. Setting the pending input region
        has copy semantics, and the wl_region object can be destroyed
        immediately. A NULL wl_region causes the input region to be set
        to infinite.
        """
        ...

    # opcode 6
    @staticmethod
    def commit() -> None:
        """
        commit pending surface state
        
        Surface state (input, opaque, and damage regions, attached buffers,
        etc.) is double-buffered. Protocol requests modify the pending state,
        as opposed to the active state in use by the compositor.
        
        A commit request atomically creates a content update from the pending
        state, even if the pending state has not been touched. The content
        update is placed in a queue until it becomes active. After commit, the
        new pending state is as documented for each related request.
        
        When the content update is applied, the wl_buffer is applied before all
        other state. This means that all coordinates in double-buffered state
        are relative to the newly attached wl_buffers, except for
        wl_surface.attach itself. If there is no newly attached wl_buffer, the
        coordinates are relative to the previous content update.
        
        All requests that need a commit to become effective are documented
        to affect double-buffered state.
        
        Other interfaces may add further double-buffered surface state.
        """
        ...

    # opcode 7
    @staticmethod
    def set_buffer_transform(transform: int) -> None:
        """
        sets the buffer transformation
        
        This request sets the transformation that the client has already applied
        to the content of the buffer. The accepted values for the transform
        parameter are the values for wl_output.transform.
        
        The compositor applies the inverse of this transformation whenever it
        uses the buffer contents.
        
        Buffer transform is double-buffered state, see wl_surface.commit.
        
        A newly created surface has its buffer transformation set to normal.
        
        wl_surface.set_buffer_transform changes the pending buffer
        transformation. wl_surface.commit copies the pending buffer
        transformation to the current one. Otherwise, the pending and current
        values are never changed.
        
        The purpose of this request is to allow clients to render content
        according to the output transform, thus permitting the compositor to
        use certain optimizations even if the display is rotated. Using
        hardware overlays and scanning out a client buffer for fullscreen
        surfaces are examples of such optimizations. Those optimizations are
        highly dependent on the compositor implementation, so the use of this
        request should be considered on a case-by-case basis.
        
        Note that if the transform value includes 90 or 270 degree rotation,
        the width of the buffer will become the surface height and the height
        of the buffer will become the surface width.
        
        If transform is not one of the values from the
        wl_output.transform enum the invalid_transform protocol error
        is raised.
        """
        ...

    # opcode 8
    @staticmethod
    def set_buffer_scale(scale: int) -> None:
        """
        sets the buffer scaling factor
        
        This request sets an optional scaling factor on how the compositor
        interprets the contents of the buffer attached to the window.
        
        Buffer scale is double-buffered state, see wl_surface.commit.
        
        A newly created surface has its buffer scale set to 1.
        
        wl_surface.set_buffer_scale changes the pending buffer scale.
        wl_surface.commit copies the pending buffer scale to the current one.
        Otherwise, the pending and current values are never changed.
        
        The purpose of this request is to allow clients to supply higher
        resolution buffer data for use on high resolution outputs. It is
        intended that you pick the same buffer scale as the scale of the
        output that the surface is displayed on. This means the compositor
        can avoid scaling when rendering the surface on that output.
        
        Note that if the scale is larger than 1, then you have to attach
        a buffer that is larger (by a factor of scale in each dimension)
        than the desired surface size.
        
        If scale is not greater than 0 the invalid_scale protocol error is
        raised.
        """
        ...

    # opcode 9
    @staticmethod
    def damage_buffer(x: int, y: int, width: int, height: int) -> None:
        """
        mark part of the surface damaged using buffer coordinates
        
        This request is used to describe the regions where the pending
        buffer is different from the current surface contents, and where
        the surface therefore needs to be repainted. The compositor
        ignores the parts of the damage that fall outside of the surface.
        
        Damage is double-buffered state, see wl_surface.commit.
        
        The damage rectangle is specified in buffer coordinates,
        where x and y specify the upper left corner of the damage rectangle.
        
        The initial value for pending damage is empty: no damage.
        wl_surface.damage_buffer adds pending damage: the new pending
        damage is the union of old pending damage and the given rectangle.
        
        wl_surface.commit assigns pending damage as the current damage,
        and clears pending damage. The server will clear the current
        damage as it repaints the surface.
        
        This request differs from wl_surface.damage in only one way - it
        takes damage in buffer coordinates instead of surface-local
        coordinates. While this generally is more intuitive than surface
        coordinates, it is especially desirable when using wp_viewport
        or when a drawing library (like EGL) is unaware of buffer scale
        and buffer transform.
        
        Note: Because buffer transformation changes and damage requests may
        be interleaved in the protocol stream, it is impossible to determine
        the actual mapping between surface and buffer damage until
        wl_surface.commit time. Therefore, compositors wishing to take both
        kinds of damage into account will have to accumulate damage from the
        two requests separately and only transform from one to the other
        after receiving the wl_surface.commit.
        """
        ...

    # opcode 10
    @staticmethod
    def offset(x: int, y: int) -> None:
        """
        set the surface contents offset
        
        The x and y arguments specify the location of the new pending
        buffer's upper left corner, relative to the current buffer's upper
        left corner, in surface-local coordinates. In other words, the
        x and y, combined with the new surface size define in which
        directions the surface's size changes.
        
        Surface location offset is double-buffered state, see
        wl_surface.commit.
        
        This request is semantically equivalent to and the replaces the x and y
        arguments in the wl_surface.attach request in wl_surface versions prior
        to 5. See wl_surface.attach for details.
        """
        ...

    class events:
        # opcode 0
        @staticmethod
        def enter(output: object) -> None:
            """
            surface enters an output
            
            This is emitted whenever a surface's creation, movement, or resizing
            results in some part of it being within the scanout region of an
            output.
            
            Note that a surface may be overlapping with zero or more outputs.
            """
            ...

        # opcode 1
        @staticmethod
        def leave(output: object) -> None:
            """
            surface leaves an output
            
            This is emitted whenever a surface's creation, movement, or resizing
            results in it no longer having any part of it within the scanout region
            of an output.
            
            Clients should not use the number of outputs the surface is on for frame
            throttling purposes. The surface might be hidden even if no leave event
            has been sent, and the compositor might expect new surface content
            updates even if no enter event has been sent. The frame event should be
            used instead.
            """
            ...

        # opcode 2
        @staticmethod
        def preferred_buffer_scale(factor: int) -> None:
            """
            preferred buffer scale for the surface
            
            This event indicates the preferred buffer scale for this surface. It is
            sent whenever the compositor's preference changes.
            
            Before receiving this event the preferred buffer scale for this surface
            is 1.
            
            It is intended that scaling aware clients use this event to scale their
            content and use wl_surface.set_buffer_scale to indicate the scale they
            have rendered with. This allows clients to supply a higher detail
            buffer.
            
            The compositor shall emit a scale value greater than 0.
            """
            ...

        # opcode 3
        @staticmethod
        def preferred_buffer_transform(transform: uint) -> None:
            """
            preferred buffer transform for the surface
            
            This event indicates the preferred buffer transform for this surface.
            It is sent whenever the compositor's preference changes.
            
            Before receiving this event the preferred buffer transform for this
            surface is normal.
            
            Applying this transformation to the surface buffer contents and using
            wl_surface.set_buffer_transform might allow the compositor to use the
            surface buffer more efficiently.
            """
            ...

class wl_seat:
    object_id = 0

    # opcode 0
    @staticmethod
    def get_pointer() -> wl_pointer:
        """
        return pointer object
        
        The ID provided will be initialized to the wl_pointer interface
        for this seat.
        
        This request only takes effect if the seat has the pointer
        capability, or has had the pointer capability in the past.
        It is a protocol violation to issue this request on a seat that has
        never had the pointer capability. The missing_capability error will
        be sent in this case.
        """
        ...

    # opcode 1
    @staticmethod
    def get_keyboard() -> wl_keyboard:
        """
        return keyboard object
        
        The ID provided will be initialized to the wl_keyboard interface
        for this seat.
        
        This request only takes effect if the seat has the keyboard
        capability, or has had the keyboard capability in the past.
        It is a protocol violation to issue this request on a seat that has
        never had the keyboard capability. The missing_capability error will
        be sent in this case.
        """
        ...

    # opcode 2
    @staticmethod
    def get_touch() -> wl_touch:
        """
        return touch object
        
        The ID provided will be initialized to the wl_touch interface
        for this seat.
        
        This request only takes effect if the seat has the touch
        capability, or has had the touch capability in the past.
        It is a protocol violation to issue this request on a seat that has
        never had the touch capability. The missing_capability error will
        be sent in this case.
        """
        ...

    # opcode 3
    @staticmethod
    def release() -> None:
        """
        release the seat object
        
        Using this request a client can tell the server that it is not going to
        use the seat object anymore.
        """
        ...

    class events:
        # opcode 0
        @staticmethod
        def capabilities(capabilities: uint) -> None:
            """
            seat capabilities changed
            
            This is emitted whenever a seat gains or loses the pointer,
            keyboard or touch capabilities.  The argument is a capability
            enum containing the complete set of capabilities this seat has.
            
            When the pointer capability is added, a client may create a
            wl_pointer object using the wl_seat.get_pointer request. This object
            will receive pointer events until the capability is removed in the
            future.
            
            When the pointer capability is removed, a client should destroy the
            wl_pointer objects associated with the seat where the capability was
            removed, using the wl_pointer.release request. No further pointer
            events will be received on these objects.
            
            In some compositors, if a seat regains the pointer capability and a
            client has a previously obtained wl_pointer object of version 4 or
            less, that object may start sending pointer events again. This
            behavior is considered a misinterpretation of the intended behavior
            and must not be relied upon by the client. wl_pointer objects of
            version 5 or later must not send events if created before the most
            recent event notifying the client of an added pointer capability.
            
            The above behavior also applies to wl_keyboard and wl_touch with the
            keyboard and touch capabilities, respectively.
            """
            ...

        # opcode 1
        @staticmethod
        def name(name: string) -> None:
            """
            unique identifier for this seat
            
            In a multi-seat configuration the seat name can be used by clients to
            help identify which physical devices the seat represents.
            
            The seat name is a UTF-8 string with no convention defined for its
            contents. Each name is unique among all wl_seat globals. The name is
            only guaranteed to be unique for the current compositor instance.
            
            The same seat names are used for all clients. Thus, the name can be
            shared across processes to refer to a specific wl_seat global.
            
            The name event is sent after binding to the seat global. This event is
            only sent once per seat object, and the name does not change over the
            lifetime of the wl_seat global.
            
            Compositors may re-use the same seat name if the wl_seat global is
            destroyed and re-created later.
            """
            ...

class wl_pointer:
    object_id = 0

    # opcode 0
    @staticmethod
    def set_cursor(serial: uint, surface: object, hotspot_x: int, hotspot_y: int) -> None:
        """
        set the pointer surface
        
        Set the pointer surface, i.e., the surface that contains the
        pointer image (cursor). This request gives the surface the role
        of a cursor. If the surface already has another role, it raises
        a protocol error.
        
        The cursor actually changes only if the pointer
        focus for this device is one of the requesting client's surfaces
        or the surface parameter is the current pointer surface. If
        there was a previous surface set with this request it is
        replaced. If surface is NULL, the pointer image is hidden.
        
        The parameters hotspot_x and hotspot_y define the position of
        the pointer surface relative to the pointer location. Its
        top-left corner is always at (x, y) - (hotspot_x, hotspot_y),
        where (x, y) are the coordinates of the pointer location, in
        surface-local coordinates.
        
        On wl_surface.offset requests to the pointer surface, hotspot_x
        and hotspot_y are decremented by the x and y parameters
        passed to the request. The offset must be applied by
        wl_surface.commit as usual.
        
        The hotspot can also be updated by passing the currently set
        pointer surface to this request with new values for hotspot_x
        and hotspot_y.
        
        The input region is ignored for wl_surfaces with the role of
        a cursor. When the use as a cursor ends, the wl_surface is
        unmapped.
        
        The serial parameter must match the latest wl_pointer.enter
        serial number sent to the client. Otherwise the request will be
        ignored.
        """
        ...

    # opcode 1
    @staticmethod
    def release() -> None:
        """
        release the pointer object
        
        Using this request a client can tell the server that it is not going to
        use the pointer object anymore.
        
        This request destroys the pointer proxy object, so clients must not call
        wl_pointer_destroy() after using this request.
        """
        ...

    class events:
        # opcode 0
        @staticmethod
        def enter(serial: uint, surface: object, surface_x: fixed, surface_y: fixed) -> None:
            """
            enter event
            
            Notification that this seat's pointer is focused on a certain
            surface.
            
            When a seat's focus enters a surface, the pointer image
            is undefined and a client should respond to this event by setting
            an appropriate pointer image with the set_cursor request.
            """
            ...

        # opcode 1
        @staticmethod
        def leave(serial: uint, surface: object) -> None:
            """
            leave event
            
            Notification that this seat's pointer is no longer focused on
            a certain surface.
            
            The leave notification is sent before the enter notification
            for the new focus.
            """
            ...

        # opcode 2
        @staticmethod
        def motion(time: uint, surface_x: fixed, surface_y: fixed) -> None:
            """
            pointer motion event
            
            Notification of pointer location change. The arguments
            surface_x and surface_y are the location relative to the
            focused surface.
            """
            ...

        # opcode 3
        @staticmethod
        def button(serial: uint, time: uint, button: uint, state: uint) -> None:
            """
            pointer button event
            
            Mouse button click and release notifications.
            
            The location of the click is given by the last motion or
            enter event.
            The time argument is a timestamp with millisecond
            granularity, with an undefined base.
            
            The button is a button code as defined in the Linux kernel's
            linux/input-event-codes.h header file, e.g. BTN_LEFT.
            
            Any 16-bit button code value is reserved for future additions to the
            kernel's event code list. All other button codes above 0xFFFF are
            currently undefined but may be used in future versions of this
            protocol.
            """
            ...

        # opcode 4
        @staticmethod
        def axis(time: uint, axis: uint, value: fixed) -> None:
            """
            axis event
            
            Scroll and other axis notifications.
            
            For scroll events (vertical and horizontal scroll axes), the
            value parameter is the length of a vector along the specified
            axis in a coordinate space identical to those of motion events,
            representing a relative movement along the specified axis.
            
            For devices that support movements non-parallel to axes multiple
            axis events will be emitted.
            
            When applicable, for example for touch pads, the server can
            choose to emit scroll events where the motion vector is
            equivalent to a motion event vector.
            
            When applicable, a client can transform its content relative to the
            scroll distance.
            """
            ...

        # opcode 5
        @staticmethod
        def frame() -> None:
            """
            end of a pointer event sequence
            
            Indicates the end of a set of events that logically belong together.
            A client is expected to accumulate the data in all events within the
            frame before proceeding.
            
            All wl_pointer events before a wl_pointer.frame event belong
            logically together. For example, in a diagonal scroll motion the
            compositor will send an optional wl_pointer.axis_source event, two
            wl_pointer.axis events (horizontal and vertical) and finally a
            wl_pointer.frame event. The client may use this information to
            calculate a diagonal vector for scrolling.
            
            When multiple wl_pointer.axis events occur within the same frame,
            the motion vector is the combined motion of all events.
            When a wl_pointer.axis and a wl_pointer.axis_stop event occur within
            the same frame, this indicates that axis movement in one axis has
            stopped but continues in the other axis.
            When multiple wl_pointer.axis_stop events occur within the same
            frame, this indicates that these axes stopped in the same instance.
            
            A wl_pointer.frame event is sent for every logical event group,
            even if the group only contains a single wl_pointer event.
            Specifically, a client may get a sequence: motion, frame, button,
            frame, axis, frame, axis_stop, frame.
            
            The wl_pointer.enter and wl_pointer.leave events are logical events
            generated by the compositor and not the hardware. These events are
            also grouped by a wl_pointer.frame. When a pointer moves from one
            surface to another, a compositor should group the
            wl_pointer.leave event within the same wl_pointer.frame.
            However, a client must not rely on wl_pointer.leave and
            wl_pointer.enter being in the same wl_pointer.frame.
            Compositor-specific policies may require the wl_pointer.leave and
            wl_pointer.enter event being split across multiple wl_pointer.frame
            groups.
            """
            ...

        # opcode 6
        @staticmethod
        def axis_source(axis_source: uint) -> None:
            """
            axis source event
            
            Source information for scroll and other axes.
            
            This event does not occur on its own. It is sent before a
            wl_pointer.frame event and carries the source information for
            all events within that frame.
            
            The source specifies how this event was generated. If the source is
            wl_pointer.axis_source.finger, a wl_pointer.axis_stop event will be
            sent when the user lifts the finger off the device.
            
            If the source is wl_pointer.axis_source.wheel,
            wl_pointer.axis_source.wheel_tilt or
            wl_pointer.axis_source.continuous, a wl_pointer.axis_stop event may
            or may not be sent. Whether a compositor sends an axis_stop event
            for these sources is hardware-specific and implementation-dependent;
            clients must not rely on receiving an axis_stop event for these
            scroll sources and should treat scroll sequences from these scroll
            sources as unterminated by default.
            
            This event is optional. If the source is unknown for a particular
            axis event sequence, no event is sent.
            Only one wl_pointer.axis_source event is permitted per frame.
            
            The order of wl_pointer.axis_discrete and wl_pointer.axis_source is
            not guaranteed.
            """
            ...

        # opcode 7
        @staticmethod
        def axis_stop(time: uint, axis: uint) -> None:
            """
            axis stop event
            
            Stop notification for scroll and other axes.
            
            For some wl_pointer.axis_source types, a wl_pointer.axis_stop event
            is sent to notify a client that the axis sequence has terminated.
            This enables the client to implement kinetic scrolling.
            See the wl_pointer.axis_source documentation for information on when
            this event may be generated.
            
            Any wl_pointer.axis events with the same axis_source after this
            event should be considered as the start of a new axis motion.
            
            The timestamp is to be interpreted identical to the timestamp in the
            wl_pointer.axis event. The timestamp value may be the same as a
            preceding wl_pointer.axis event.
            """
            ...

        # opcode 8
        @staticmethod
        def axis_discrete(axis: uint, discrete: int) -> None:
            """
            axis click event
            
            Discrete step information for scroll and other axes.
            
            This event carries the axis value of the wl_pointer.axis event in
            discrete steps (e.g. mouse wheel clicks).
            
            This event is deprecated with wl_pointer version 8 - this event is not
            sent to clients supporting version 8 or later.
            
            This event does not occur on its own, it is coupled with a
            wl_pointer.axis event that represents this axis value on a
            continuous scale. The protocol guarantees that each axis_discrete
            event is always followed by exactly one axis event with the same
            axis number within the same wl_pointer.frame. Note that the protocol
            allows for other events to occur between the axis_discrete and
            its coupled axis event, including other axis_discrete or axis
            events. A wl_pointer.frame must not contain more than one axis_discrete
            event per axis type.
            
            This event is optional; continuous scrolling devices
            like two-finger scrolling on touchpads do not have discrete
            steps and do not generate this event.
            
            The discrete value carries the directional information. e.g. a value
            of -2 is two steps towards the negative direction of this axis.
            
            The axis number is identical to the axis number in the associated
            axis event.
            
            The order of wl_pointer.axis_discrete and wl_pointer.axis_source is
            not guaranteed.
            """
            ...

        # opcode 9
        @staticmethod
        def axis_value120(axis: uint, value120: int) -> None:
            """
            axis high-resolution scroll event
            
            Discrete high-resolution scroll information.
            
            This event carries high-resolution wheel scroll information,
            with each multiple of 120 representing one logical scroll step
            (a wheel detent). For example, an axis_value120 of 30 is one quarter of
            a logical scroll step in the positive direction, a value120 of
            -240 are two logical scroll steps in the negative direction within the
            same hardware event.
            Clients that rely on discrete scrolling should accumulate the
            value120 to multiples of 120 before processing the event.
            
            The value120 must not be zero.
            
            This event replaces the wl_pointer.axis_discrete event in clients
            supporting wl_pointer version 8 or later.
            
            Where a wl_pointer.axis_source event occurs in the same
            wl_pointer.frame, the axis source applies to this event.
            
            The order of wl_pointer.axis_value120 and wl_pointer.axis_source is
            not guaranteed.
            """
            ...

        # opcode 10
        @staticmethod
        def axis_relative_direction(axis: uint, direction: uint) -> None:
            """
            axis relative physical direction event
            
            Relative directional information of the entity causing the axis
            motion.
            
            For a wl_pointer.axis event, the wl_pointer.axis_relative_direction
            event specifies the movement direction of the entity causing the
            wl_pointer.axis event. For example:
            - if a user's fingers on a touchpad move down and this
            causes a wl_pointer.axis vertical_scroll down event, the physical
            direction is 'identical'
            - if a user's fingers on a touchpad move down and this causes a
            wl_pointer.axis vertical_scroll up scroll up event ('natural
            scrolling'), the physical direction is 'inverted'.
            
            A client may use this information to adjust scroll motion of
            components. Specifically, enabling natural scrolling causes the
            content to change direction compared to traditional scrolling.
            Some widgets like volume control sliders should usually match the
            physical direction regardless of whether natural scrolling is
            active. This event enables clients to match the scroll direction of
            a widget to the physical direction.
            
            This event does not occur on its own, it is coupled with a
            wl_pointer.axis event that represents this axis value.
            The protocol guarantees that each axis_relative_direction event is
            always followed by exactly one axis event with the same
            axis number within the same wl_pointer.frame. Note that the protocol
            allows for other events to occur between the axis_relative_direction
            and its coupled axis event.
            
            The axis number is identical to the axis number in the associated
            axis event.
            
            The order of wl_pointer.axis_relative_direction,
            wl_pointer.axis_discrete and wl_pointer.axis_source is not
            guaranteed.
            """
            ...

class wl_keyboard:
    object_id = 0

    # opcode 0
    @staticmethod
    def release() -> None:
        """
        release the keyboard object
        """
        ...

    class events:
        # opcode 0
        @staticmethod
        def keymap(format: uint, fd: fd, size: uint) -> None:
            """
            keyboard mapping
            
            This event provides a file descriptor to the client which can be
            memory-mapped in read-only mode to provide a keyboard mapping
            description.
            
            From version 7 onwards, the fd must be mapped with MAP_PRIVATE by
            the recipient, as MAP_SHARED may fail.
            """
            ...

        # opcode 1
        @staticmethod
        def enter(serial: uint, surface: object, keys: array) -> None:
            """
            enter event
            
            Notification that this seat's keyboard focus is on a certain
            surface.
            
            The compositor must send the wl_keyboard.modifiers event after this
            event.
            
            In the wl_keyboard logical state, this event sets the active surface to
            the surface argument and the keys currently logically down to the keys
            in the keys argument. The compositor must not send this event if the
            wl_keyboard already had an active surface immediately before this event.
            """
            ...

        # opcode 2
        @staticmethod
        def leave(serial: uint, surface: object) -> None:
            """
            leave event
            
            Notification that this seat's keyboard focus is no longer on
            a certain surface.
            
            The leave notification is sent before the enter notification
            for the new focus.
            
            In the wl_keyboard logical state, this event resets all values to their
            defaults. The compositor must not send this event if the active surface
            of the wl_keyboard was not equal to the surface argument immediately
            before this event.
            """
            ...

        # opcode 3
        @staticmethod
        def key(serial: uint, time: uint, key: uint, state: uint) -> None:
            """
            key event
            
            A key was pressed or released.
            The time argument is a timestamp with millisecond
            granularity, with an undefined base.
            
            The key is a platform-specific key code that can be interpreted
            by feeding it to the keyboard mapping (see the keymap event).
            
            If this event produces a change in modifiers, then the resulting
            wl_keyboard.modifiers event must be sent after this event.
            
            In the wl_keyboard logical state, this event adds the key to the keys
            currently logically down (if the state argument is pressed) or removes
            the key from the keys currently logically down (if the state argument is
            released). The compositor must not send this event if the wl_keyboard
            did not have an active surface immediately before this event. The
            compositor must not send this event if state is pressed (resp. released)
            and the key was already logically down (resp. was not logically down)
            immediately before this event.
            """
            ...

        # opcode 4
        @staticmethod
        def modifiers(serial: uint, mods_depressed: uint, mods_latched: uint, mods_locked: uint, group: uint) -> None:
            """
            modifier and group state
            
            Notifies clients that the modifier and/or group state has
            changed, and it should update its local state.
            
            The compositor may send this event without a surface of the client
            having keyboard focus, for example to tie modifier information to
            pointer focus instead. If a modifier event with pressed modifiers is sent
            without a prior enter event, the client can assume the modifier state is
            valid until it receives the next wl_keyboard.modifiers event. In order to
            reset the modifier state again, the compositor can send a
            wl_keyboard.modifiers event with no pressed modifiers.
            
            In the wl_keyboard logical state, this event updates the modifiers and
            group.
            """
            ...

        # opcode 5
        @staticmethod
        def repeat_info(rate: int, delay: int) -> None:
            """
            repeat rate and delay
            
            Informs the client about the keyboard's repeat rate and delay.
            
            This event is sent as soon as the wl_keyboard object has been created,
            and is guaranteed to be received by the client before any key press
            event.
            
            Negative values for either rate or delay are illegal. A rate of zero
            will disable any repeating (regardless of the value of delay).
            
            This event can be sent later on as well with a new value if necessary,
            so clients should continue listening for the event past the creation
            of wl_keyboard.
            """
            ...

class wl_touch:
    object_id = 0

    # opcode 0
    @staticmethod
    def release() -> None:
        """
        release the touch object
        """
        ...

    class events:
        # opcode 0
        @staticmethod
        def down(serial: uint, time: uint, surface: object, id: int, x: fixed, y: fixed) -> None:
            """
            touch down event and beginning of a touch sequence
            
            A new touch point has appeared on the surface. This touch point is
            assigned a unique ID. Future events from this touch point reference
            this ID. The ID ceases to be valid after a touch up event and may be
            reused in the future.
            """
            ...

        # opcode 1
        @staticmethod
        def up(serial: uint, time: uint, id: int) -> None:
            """
            end of a touch event sequence
            
            The touch point has disappeared. No further events will be sent for
            this touch point and the touch point's ID is released and may be
            reused in a future touch down event.
            """
            ...

        # opcode 2
        @staticmethod
        def motion(time: uint, id: int, x: fixed, y: fixed) -> None:
            """
            update of touch point coordinates
            
            A touch point has changed coordinates.
            """
            ...

        # opcode 3
        @staticmethod
        def frame() -> None:
            """
            end of touch frame event
            
            Indicates the end of a set of events that logically belong together.
            A client is expected to accumulate the data in all events within the
            frame before proceeding.
            
            A wl_touch.frame terminates at least one event but otherwise no
            guarantee is provided about the set of events within a frame. A client
            must assume that any state not updated in a frame is unchanged from the
            previously known state.
            """
            ...

        # opcode 4
        @staticmethod
        def cancel() -> None:
            """
            touch session cancelled
            
            Sent if the compositor decides the touch stream is a global
            gesture. No further events are sent to the clients from that
            particular gesture. Touch cancellation applies to all touch points
            currently active on this client's surface. The client is
            responsible for finalizing the touch points, future touch points on
            this surface may reuse the touch point ID.
            
            No frame event is required after the cancel event.
            """
            ...

        # opcode 5
        @staticmethod
        def shape(id: int, major: fixed, minor: fixed) -> None:
            """
            update shape of touch point
            
            Sent when a touchpoint has changed its shape.
            
            This event does not occur on its own. It is sent before a
            wl_touch.frame event and carries the new shape information for
            any previously reported, or new touch points of that frame.
            
            Other events describing the touch point such as wl_touch.down,
            wl_touch.motion or wl_touch.orientation may be sent within the
            same wl_touch.frame. A client should treat these events as a single
            logical touch point update. The order of wl_touch.shape,
            wl_touch.orientation and wl_touch.motion is not guaranteed.
            A wl_touch.down event is guaranteed to occur before the first
            wl_touch.shape event for this touch ID but both events may occur within
            the same wl_touch.frame.
            
            A touchpoint shape is approximated by an ellipse through the major and
            minor axis length. The major axis length describes the longer diameter
            of the ellipse, while the minor axis length describes the shorter
            diameter. Major and minor are orthogonal and both are specified in
            surface-local coordinates. The center of the ellipse is always at the
            touchpoint location as reported by wl_touch.down or wl_touch.move.
            
            This event is only sent by the compositor if the touch device supports
            shape reports. The client has to make reasonable assumptions about the
            shape if it did not receive this event.
            """
            ...

        # opcode 6
        @staticmethod
        def orientation(id: int, orientation: fixed) -> None:
            """
            update orientation of touch point
            
            Sent when a touchpoint has changed its orientation.
            
            This event does not occur on its own. It is sent before a
            wl_touch.frame event and carries the new shape information for
            any previously reported, or new touch points of that frame.
            
            Other events describing the touch point such as wl_touch.down,
            wl_touch.motion or wl_touch.shape may be sent within the
            same wl_touch.frame. A client should treat these events as a single
            logical touch point update. The order of wl_touch.shape,
            wl_touch.orientation and wl_touch.motion is not guaranteed.
            A wl_touch.down event is guaranteed to occur before the first
            wl_touch.orientation event for this touch ID but both events may occur
            within the same wl_touch.frame.
            
            The orientation describes the clockwise angle of a touchpoint's major
            axis to the positive surface y-axis and is normalized to the -180 to
            +180 degree range. The granularity of orientation depends on the touch
            device, some devices only support binary rotation values between 0 and
            90 degrees.
            
            This event is only sent by the compositor if the touch device supports
            orientation reports.
            """
            ...

class wl_output:
    object_id = 0

    # opcode 0
    @staticmethod
    def release() -> None:
        """
        release the output object
        
        Using this request a client can tell the server that it is not going to
        use the output object anymore.
        """
        ...

    class events:
        # opcode 0
        @staticmethod
        def geometry(x: int, y: int, physical_width: int, physical_height: int, subpixel: int, make: string, model: string, transform: int) -> None:
            """
            properties of the output
            
            The geometry event describes geometric properties of the output.
            The event is sent when binding to the output object and whenever
            any of the properties change.
            
            The physical size can be set to zero if it doesn't make sense for this
            output (e.g. for projectors or virtual outputs).
            
            The geometry event will be followed by a done event (starting from
            version 2).
            
            Clients should use wl_surface.preferred_buffer_transform instead of the
            transform advertised by this event to find the preferred buffer
            transform to use for a surface.
            
            Note: wl_output only advertises partial information about the output
            position and identification. Some compositors, for instance those not
            implementing a desktop-style output layout or those exposing virtual
            outputs, might fake this information. Instead of using x and y, clients
            should use xdg_output.logical_position. Instead of using make and model,
            clients should use name and description.
            """
            ...

        # opcode 1
        @staticmethod
        def mode(flags: uint, width: int, height: int, refresh: int) -> None:
            """
            advertise available modes for the output
            
            The mode event describes an available mode for the output.
            
            The event is sent when binding to the output object and there
            will always be one mode, the current mode.  The event is sent
            again if an output changes mode, for the mode that is now
            current.  In other words, the current mode is always the last
            mode that was received with the current flag set.
            
            Non-current modes are deprecated. A compositor can decide to only
            advertise the current mode and never send other modes. Clients
            should not rely on non-current modes.
            
            The size of a mode is given in physical hardware units of
            the output device. This is not necessarily the same as
            the output size in the global compositor space. For instance,
            the output may be scaled, as described in wl_output.scale,
            or transformed, as described in wl_output.transform. Clients
            willing to retrieve the output size in the global compositor
            space should use xdg_output.logical_size instead.
            
            The vertical refresh rate can be set to zero if it doesn't make
            sense for this output (e.g. for virtual outputs).
            
            The mode event will be followed by a done event (starting from
            version 2).
            
            Clients should not use the refresh rate to schedule frames. Instead,
            they should use the wl_surface.frame event or the presentation-time
            protocol.
            
            Note: this information is not always meaningful for all outputs. Some
            compositors, such as those exposing virtual outputs, might fake the
            refresh rate or the size.
            """
            ...

        # opcode 2
        @staticmethod
        def done() -> None:
            """
            sent all information about output
            
            This event is sent after all other properties have been
            sent after binding to the output object and after any
            other property changes done after that. This allows
            changes to the output properties to be seen as
            atomic, even if they happen via multiple events.
            """
            ...

        # opcode 3
        @staticmethod
        def scale(factor: int) -> None:
            """
            output scaling properties
            
            This event contains scaling geometry information
            that is not in the geometry event. It may be sent after
            binding the output object or if the output scale changes
            later. The compositor will emit a non-zero, positive
            value for scale. If it is not sent, the client should
            assume a scale of 1.
            
            A scale larger than 1 means that the compositor will
            automatically scale surface buffers by this amount
            when rendering. This is used for very high resolution
            displays where applications rendering at the native
            resolution would be too small to be legible.
            
            Clients should use wl_surface.preferred_buffer_scale
            instead of this event to find the preferred buffer
            scale to use for a surface.
            
            The scale event will be followed by a done event.
            """
            ...

        # opcode 4
        @staticmethod
        def name(name: string) -> None:
            """
            name of this output
            
            Many compositors will assign user-friendly names to their outputs, show
            them to the user, allow the user to refer to an output, etc. The client
            may wish to know this name as well to offer the user similar behaviors.
            
            The name is a UTF-8 string with no convention defined for its contents.
            Each name is unique among all wl_output globals. The name is only
            guaranteed to be unique for the compositor instance.
            
            The same output name is used for all clients for a given wl_output
            global. Thus, the name can be shared across processes to refer to a
            specific wl_output global.
            
            The name is not guaranteed to be persistent across sessions, thus cannot
            be used to reliably identify an output in e.g. configuration files.
            
            Examples of names include 'HDMI-A-1', 'WL-1', 'X11-1', etc. However, do
            not assume that the name is a reflection of an underlying DRM connector,
            X11 connection, etc.
            
            The name event is sent after binding the output object. This event is
            only sent once per output object, and the name does not change over the
            lifetime of the wl_output global.
            
            Compositors may re-use the same output name if the wl_output global is
            destroyed and re-created later. Compositors should avoid re-using the
            same name if possible.
            
            The name event will be followed by a done event.
            """
            ...

        # opcode 5
        @staticmethod
        def description(description: string) -> None:
            """
            human-readable description of this output
            
            Many compositors can produce human-readable descriptions of their
            outputs. The client may wish to know this description as well, e.g. for
            output selection purposes.
            
            The description is a UTF-8 string with no convention defined for its
            contents. The description is not guaranteed to be unique among all
            wl_output globals. Examples might include 'Foocorp 11" Display' or
            'Virtual X11 output via :1'.
            
            The description event is sent after binding the output object and
            whenever the description changes. The description is optional, and may
            not be sent at all.
            
            The description event will be followed by a done event.
            """
            ...

class wl_region:
    object_id = 0

    # opcode 0
    @staticmethod
    def destroy() -> None:
        """
        destroy region
        
        Destroy the region.  This will invalidate the object ID.
        """
        ...

    # opcode 1
    @staticmethod
    def add(x: int, y: int, width: int, height: int) -> None:
        """
        add rectangle to region
        
        Add the specified rectangle to the region.
        """
        ...

    # opcode 2
    @staticmethod
    def subtract(x: int, y: int, width: int, height: int) -> None:
        """
        subtract rectangle from region
        
        Subtract the specified rectangle from the region.
        """
        ...

class wl_subcompositor:
    object_id = 0

    # opcode 0
    @staticmethod
    def destroy() -> None:
        """
        unbind from the subcompositor interface
        
        Informs the server that the client will not be using this
        protocol object anymore. This does not affect any other
        objects, wl_subsurface objects included.
        """
        ...

    # opcode 1
    @staticmethod
    def get_subsurface(surface: object, parent: object) -> wl_subsurface:
        """
        give a surface the role sub-surface
        
        Create a sub-surface interface for the given surface, and
        associate it with the given parent surface. This turns a
        plain wl_surface into a sub-surface.
        
        The to-be sub-surface must not already have another role, and it
        must not have an existing wl_subsurface object. Otherwise the
        bad_surface protocol error is raised.
        
        Adding sub-surfaces to a parent is a double-buffered operation on the
        parent (see wl_surface.commit). The effect of adding a sub-surface
        becomes visible on the next time the state of the parent surface is
        applied.
        
        The parent surface must not be one of the child surface's descendants,
        and the parent must be different from the child surface, otherwise the
        bad_parent protocol error is raised.
        
        This request modifies the behaviour of wl_surface.commit request on
        the sub-surface, see the documentation on wl_subsurface interface.
        """
        ...

class wl_subsurface:
    object_id = 0

    # opcode 0
    @staticmethod
    def destroy() -> None:
        """
        remove sub-surface interface
        
        The sub-surface interface is removed from the wl_surface object
        that was turned into a sub-surface with a
        wl_subcompositor.get_subsurface request. The wl_surface's association
        to the parent is deleted. The wl_surface is unmapped immediately.
        """
        ...

    # opcode 1
    @staticmethod
    def set_position(x: int, y: int) -> None:
        """
        reposition the sub-surface
        
        This schedules a sub-surface position change.
        The sub-surface will be moved so that its origin (top left
        corner pixel) will be at the location x, y of the parent surface
        coordinate system. The coordinates are not restricted to the parent
        surface area. Negative values are allowed.
        
        The scheduled coordinates will take effect whenever the state of the
        parent surface is applied.
        
        If more than one set_position request is invoked by the client before
        the commit of the parent surface, the position of a new request always
        replaces the scheduled position from any previous request.
        
        The initial position is 0, 0.
        """
        ...

    # opcode 2
    @staticmethod
    def place_above(sibling: object) -> None:
        """
        restack the sub-surface
        
        This sub-surface is taken from the stack, and put back just
        above the reference surface, changing the z-order of the sub-surfaces.
        The reference surface must be one of the sibling surfaces, or the
        parent surface. Using any other surface, including this sub-surface,
        will cause a protocol error.
        
        The z-order is double-buffered. Requests are handled in order and
        applied immediately to a pending state. The final pending state is
        copied to the active state the next time the state of the parent
        surface is applied.
        
        A new sub-surface is initially added as the top-most in the stack
        of its siblings and parent.
        """
        ...

    # opcode 3
    @staticmethod
    def place_below(sibling: object) -> None:
        """
        restack the sub-surface
        
        The sub-surface is placed just below the reference surface.
        See wl_subsurface.place_above.
        """
        ...

    # opcode 4
    @staticmethod
    def set_sync() -> None:
        """
        set sub-surface to synchronized mode
        
        Change the commit behaviour of the sub-surface to synchronized
        mode, also described as the parent dependent mode.
        
        In synchronized mode, wl_surface.commit on a sub-surface will
        accumulate the committed state in a cache, but the state will
        not be applied and hence will not change the compositor output.
        The cached state is applied to the sub-surface immediately after
        the parent surface's state is applied. This ensures atomic
        updates of the parent and all its synchronized sub-surfaces.
        Applying the cached state will invalidate the cache, so further
        parent surface commits do not (re-)apply old state.
        
        See wl_subsurface for the recursive effect of this mode.
        """
        ...

    # opcode 5
    @staticmethod
    def set_desync() -> None:
        """
        set sub-surface to desynchronized mode
        
        Change the commit behaviour of the sub-surface to desynchronized
        mode, also described as independent or freely running mode.
        
        In desynchronized mode, wl_surface.commit on a sub-surface will
        apply the pending state directly, without caching, as happens
        normally with a wl_surface. Calling wl_surface.commit on the
        parent surface has no effect on the sub-surface's wl_surface
        state. This mode allows a sub-surface to be updated on its own.
        
        If cached state exists when wl_surface.commit is called in
        desynchronized mode, the pending state is added to the cached
        state, and applied as a whole. This invalidates the cache.
        
        Note: even if a sub-surface is set to desynchronized, a parent
        sub-surface may override it to behave as synchronized. For details,
        see wl_subsurface.
        
        If a surface's parent surface behaves as desynchronized, then
        the cached state is applied on set_desync.
        """
        ...

class wl_callback:
    object_id = 0

    class events:
        # opcode 0
        @staticmethod
        def done(callback_data: uint) -> None:
            """
            done event
            
            Notify the client when the related request is done.
            """
            ...

class wp_alpha_modifier_v1:
    object_id = 0

    # opcode 0
    @staticmethod
    def destroy() -> None:
        """
        destroy the alpha modifier manager object
        
        Destroy the alpha modifier manager. This doesn't destroy objects
        created with the manager.
        """
        ...

    # opcode 1
    @staticmethod
    def get_surface(surface: object) -> wp_alpha_modifier_surface_v1:
        """
        create a new toplevel decoration object
        
        Create a new alpha modifier surface object associated with the
        given wl_surface. If there is already such an object associated with
        the wl_surface, the already_constructed error will be raised.
        """
        ...

class wp_alpha_modifier_surface_v1:
    object_id = 0

    # opcode 0
    @staticmethod
    def destroy() -> None:
        """
        destroy the alpha modifier object
        
        This destroys the object, and is equivalent to set_multiplier with
        a value of UINT32_MAX, with the same double-buffered semantics as
        set_multiplier.
        """
        ...

    # opcode 1
    @staticmethod
    def set_multiplier(factor: uint) -> None:
        """
        specify the alpha multiplier
        
        Sets the alpha multiplier for the surface. The alpha multiplier is
        double-buffered state, see wl_surface.commit for details.
        
        This factor is applied in the compositor's blending space, as an
        additional step after the processing of per-pixel alpha values for the
        wl_surface. The exact meaning of the factor is thus undefined, unless
        the blending space is specified in a different extension.
        
        This multiplier is applied even if the buffer attached to the
        wl_surface doesn't have an alpha channel; in that case an alpha value
        of one is used instead.
        
        Zero means completely transparent, UINT32_MAX means completely opaque.
        """
        ...

class wp_content_type_manager_v1:
    object_id = 0

    # opcode 0
    @staticmethod
    def destroy() -> None:
        """
        destroy the content type manager object
        
        Destroy the content type manager. This doesn't destroy objects created
        with the manager.
        """
        ...

    # opcode 1
    @staticmethod
    def get_surface_content_type(surface: object) -> wp_content_type_v1:
        """
        create a new toplevel decoration object
        
        Create a new content type object associated with the given surface.
        
        Creating a wp_content_type_v1 from a wl_surface which already has one
        attached is a client error: already_constructed.
        """
        ...

class wp_content_type_v1:
    object_id = 0

    # opcode 0
    @staticmethod
    def destroy() -> None:
        """
        destroy the content type object
        
        Switch back to not specifying the content type of this surface. This is
        equivalent to setting the content type to none, including double
        buffering semantics. See set_content_type for details.
        """
        ...

    # opcode 1
    @staticmethod
    def set_content_type(content_type: uint) -> None:
        """
        specify the content type
        
        Set the surface content type. This informs the compositor that the
        client believes it is displaying buffers matching this content type.
        
        This is purely a hint for the compositor, which can be used to adjust
        its behavior or hardware settings to fit the presented content best.
        
        The content type is double-buffered state, see wl_surface.commit for
        details.
        """
        ...

class wp_cursor_shape_manager_v1:
    object_id = 0

    # opcode 0
    @staticmethod
    def destroy() -> None:
        """
        destroy the manager
        
        Destroy the cursor shape manager.
        """
        ...

    # opcode 1
    @staticmethod
    def get_pointer(pointer: object) -> wp_cursor_shape_device_v1:
        """
        manage the cursor shape of a pointer device
        
        Obtain a wp_cursor_shape_device_v1 for a wl_pointer object.
        """
        ...

    # opcode 2
    @staticmethod
    def get_tablet_tool_v2(tablet_tool: object) -> wp_cursor_shape_device_v1:
        """
        manage the cursor shape of a tablet tool device
        
        Obtain a wp_cursor_shape_device_v1 for a zwp_tablet_tool_v2 object.
        """
        ...

class wp_cursor_shape_device_v1:
    object_id = 0

    # opcode 0
    @staticmethod
    def destroy() -> None:
        """
        destroy the cursor shape device
        
        Destroy the cursor shape device.
        
        The device cursor shape remains unchanged.
        """
        ...

    # opcode 1
    @staticmethod
    def set_shape(serial: uint, shape: uint) -> None:
        """
        set device cursor to the shape
        
        Sets the device cursor to the specified shape. The compositor will
        change the cursor image based on the specified shape.
        
        The cursor actually changes only if the input device focus is one of
        the requesting client's surfaces. If any, the previous cursor image
        (surface or shape) is replaced.
        
        The "shape" argument must be a valid enum entry, otherwise the
        invalid_shape protocol error is raised.
        
        This is similar to the wl_pointer.set_cursor and
        zwp_tablet_tool_v2.set_cursor requests, but this request accepts a
        shape instead of contents in the form of a surface. Clients can mix
        set_cursor and set_shape requests.
        
        The serial parameter must match the latest wl_pointer.enter or
        zwp_tablet_tool_v2.proximity_in serial number sent to the client.
        Otherwise the request will be ignored.
        """
        ...

class wp_drm_lease_device_v1:
    object_id = 0

    # opcode 0
    @staticmethod
    def create_lease_request() -> wp_drm_lease_request_v1:
        """
        create a lease request object
        
        Creates a lease request object.
        
        See the documentation for wp_drm_lease_request_v1 for details.
        """
        ...

    # opcode 1
    @staticmethod
    def release() -> None:
        """
        release this object
        
        Indicates the client no longer wishes to use this object. In response
        the compositor will immediately send the released event and destroy
        this object. It can however not guarantee that the client won't receive
        connector events before the released event. The client must not send any
        requests after this one, doing so will raise a wl_display error.
        Existing connectors, lease request and leases will not be affected.
        """
        ...

    class events:
        # opcode 0
        @staticmethod
        def drm_fd(fd: fd) -> None:
            """
            open a non-master fd for this DRM node
            
            The compositor will send this event when the wp_drm_lease_device_v1
            global is bound, although there are no guarantees as to how long this
            takes - the compositor might need to wait until regaining DRM master.
            The included fd is a non-master DRM file descriptor opened for this
            device and the compositor must not authenticate it.
            The purpose of this event is to give the client the ability to
            query DRM and discover information which may help them pick the
            appropriate DRM device or select the appropriate connectors therein.
            """
            ...

        # opcode 1
        @staticmethod
        def connector(id: wp_drm_lease_connector_v1) -> None:
            """
            advertise connectors available for leases
            
            The compositor will use this event to advertise connectors available for
            lease by clients. This object may be passed into a lease request to
            indicate the client would like to lease that connector, see
            wp_drm_lease_request_v1.request_connector for details. While the
            compositor will make a best effort to not send disconnected connectors,
            no guarantees can be made.
            
            The compositor must send the drm_fd event before sending connectors.
            After the drm_fd event it will send all available connectors but may
            send additional connectors at any time.
            """
            ...

        # opcode 2
        @staticmethod
        def done() -> None:
            """
            signals grouping of connectors
            
            The compositor will send this event to indicate that it has sent all
            currently available connectors after the client binds to the global or
            when it updates the connector list, for example on hotplug, drm master
            change or when a leased connector becomes available again. It will
            similarly send this event to group wp_drm_lease_connector_v1.withdrawn
            events of connectors of this device.
            """
            ...

        # opcode 3
        @staticmethod
        def released() -> None:
            """
            the compositor has finished using the device
            
            This event is sent in response to the release request and indicates
            that the compositor is done sending connector events.
            The compositor will destroy this object immediately after sending the
            event and it will become invalid. The client should release any
            resources associated with this device after receiving this event.
            """
            ...

class wp_drm_lease_connector_v1:
    object_id = 0

    # opcode 0
    @staticmethod
    def destroy() -> None:
        """
        destroy connector
        
        The client may send this request to indicate that it will not use this
        connector. Clients are encouraged to send this after receiving the
        "withdrawn" event so that the server can release the resources
        associated with this connector offer. Neither existing lease requests
        nor leases will be affected.
        """
        ...

    class events:
        # opcode 0
        @staticmethod
        def name(name: string) -> None:
            """
            name
            
            The compositor sends this event once the connector is created to
            indicate the name of this connector. This will not change for the
            duration of the Wayland session, but is not guaranteed to be consistent
            between sessions.
            
            If the compositor supports wl_output version 4 and this connector
            corresponds to a wl_output, the compositor should use the same name as
            for the wl_output.
            """
            ...

        # opcode 1
        @staticmethod
        def description(description: string) -> None:
            """
            description
            
            The compositor sends this event once the connector is created to provide
            a human-readable description for this connector, which may be presented
            to the user. The compositor may send this event multiple times over the
            lifetime of this object to reflect changes in the description.
            """
            ...

        # opcode 2
        @staticmethod
        def connector_id(connector_id: uint) -> None:
            """
            connector_id
            
            The compositor sends this event once the connector is created to
            indicate the DRM object ID which represents the underlying connector
            that is being offered. Note that the final lease may include additional
            object IDs, such as CRTCs and planes.
            """
            ...

        # opcode 3
        @staticmethod
        def done() -> None:
            """
            all properties have been sent
            
            This event is sent after all properties of a connector have been sent.
            This allows changes to the properties to be seen as atomic even if they
            happen via multiple events.
            """
            ...

        # opcode 4
        @staticmethod
        def withdrawn() -> None:
            """
            lease offer withdrawn
            
            Sent to indicate that the compositor will no longer honor requests for
            DRM leases which include this connector. The client may still issue a
            lease request including this connector, but the compositor will send
            wp_drm_lease_v1.finished without issuing a lease fd. Compositors are
            encouraged to send this event when they lose access to connector, for
            example when the connector is hot-unplugged, when the connector gets
            leased to a client or when the compositor loses DRM master.
            """
            ...

class wp_drm_lease_request_v1:
    object_id = 0

    # opcode 0
    @staticmethod
    def request_connector(connector: object) -> None:
        """
        request a connector for this lease
        
        Indicates that the client would like to lease the given connector.
        This is only used as a suggestion, the compositor may choose to
        include any resources in the lease it issues, or change the set of
        leased resources at any time. Compositors are however encouraged to
        include the requested connector and other resources necessary
        to drive the connected output in the lease.
        
        Requesting a connector that was created from a different lease device
        than this lease request raises the wrong_device error. Requesting a
        connector twice will raise the duplicate_connector error.
        """
        ...

    # opcode 1
    @staticmethod
    def submit() -> wp_drm_lease_v1:
        """
        submit the lease request
        
        Submits the lease request and creates a new wp_drm_lease_v1 object.
        After calling submit the compositor will immediately destroy this
        object, issuing any more requests will cause a wl_display error.
        The compositor doesn't make any guarantees about the events of the
        lease object, clients cannot expect an immediate response.
        Not requesting any connectors before submitting the lease request
        will raise the empty_lease error.
        """
        ...

class wp_drm_lease_v1:
    object_id = 0

    # opcode 0
    @staticmethod
    def destroy() -> None:
        """
        destroys the lease object
        
        The client should send this to indicate that it no longer wishes to use
        this lease. The compositor should use drmModeRevokeLease on the
        appropriate file descriptor, if necessary.
        """
        ...

    class events:
        # opcode 0
        @staticmethod
        def lease_fd(leased_fd: fd) -> None:
            """
            shares the DRM file descriptor
            
            This event returns a file descriptor suitable for use with DRM-related
            ioctls. The client should use drmModeGetLease to enumerate the DRM
            objects which have been leased to them. The compositor guarantees it
            will not use the leased DRM objects itself until it sends the finished
            event. If the compositor cannot or will not grant a lease for the
            requested connectors, it will not send this event, instead sending the
            finished event.
            
            The compositor will send this event at most once during this objects
            lifetime.
            """
            ...

        # opcode 1
        @staticmethod
        def finished() -> None:
            """
            sent when the lease has been revoked
            
            The compositor uses this event to either reject a lease request, or if
            it previously sent a lease_fd, to notify the client that the lease has
            been revoked. If the client requires a new lease, they should destroy
            this object and submit a new lease request. The compositor will send
            no further events for this object after sending the finish event.
            Compositors should revoke the lease when any of the leased resources
            become unavailable, namely when a hot-unplug occurs or when the
            compositor loses DRM master.
            """
            ...

class ext_foreign_toplevel_list_v1:
    object_id = 0

    # opcode 0
    @staticmethod
    def stop() -> None:
        """
        stop sending events
        
        This request indicates that the client no longer wishes to receive
        events for new toplevels.
        
        The Wayland protocol is asynchronous, meaning the compositor may send
        further toplevel events until the stop request is processed.
        The client should wait for a ext_foreign_toplevel_list_v1.finished
        event before destroying this object.
        """
        ...

    # opcode 1
    @staticmethod
    def destroy() -> None:
        """
        destroy the ext_foreign_toplevel_list_v1 object
        
        This request should be called either when the client will no longer
        use the ext_foreign_toplevel_list_v1 or after the finished event
        has been received to allow destruction of the object.
        
        If a client wishes to destroy this object it should send a
        ext_foreign_toplevel_list_v1.stop request and wait for a ext_foreign_toplevel_list_v1.finished
        event, then destroy the handles and then this object.
        """
        ...

    class events:
        # opcode 0
        @staticmethod
        def toplevel(toplevel: ext_foreign_toplevel_handle_v1) -> None:
            """
            a toplevel has been created
            
            This event is emitted whenever a new toplevel window is created. It is
            emitted for all toplevels, regardless of the app that has created them.
            
            All initial properties of the toplevel (identifier, title, app_id) will be sent
            immediately after this event using the corresponding events for
            ext_foreign_toplevel_handle_v1. The compositor will use the
            ext_foreign_toplevel_handle_v1.done event to indicate when all data has
            been sent.
            """
            ...

        # opcode 1
        @staticmethod
        def finished() -> None:
            """
            the compositor has finished with the toplevel manager
            
            This event indicates that the compositor is done sending events
            to this object. The client should destroy the object.
            See ext_foreign_toplevel_list_v1.destroy for more information.
            
            The compositor must not send any more toplevel events after this event.
            """
            ...

class ext_foreign_toplevel_handle_v1:
    object_id = 0

    # opcode 0
    @staticmethod
    def destroy() -> None:
        """
        destroy the ext_foreign_toplevel_handle_v1 object
        
        This request should be used when the client will no longer use the handle
        or after the closed event has been received to allow destruction of the
        object.
        
        When a handle is destroyed, a new handle may not be created by the server
        until the toplevel is unmapped and then remapped. Destroying a toplevel handle
        is not recommended unless the client is cleaning up child objects
        before destroying the ext_foreign_toplevel_list_v1 object, the toplevel
        was closed or the toplevel handle will not be used in the future.
        
        Other protocols which extend the ext_foreign_toplevel_handle_v1
        interface should require destructors for extension interfaces be
        called before allowing the toplevel handle to be destroyed.
        """
        ...

    class events:
        # opcode 0
        @staticmethod
        def closed() -> None:
            """
            the toplevel has been closed
            
            The server will emit no further events on the ext_foreign_toplevel_handle_v1
            after this event. Any requests received aside from the destroy request must
            be ignored. Upon receiving this event, the client should destroy the handle.
            
            Other protocols which extend the ext_foreign_toplevel_handle_v1
            interface must also ignore requests other than destructors.
            """
            ...

        # opcode 1
        @staticmethod
        def done() -> None:
            """
            all information about the toplevel has been sent
            
            This event is sent after all changes in the toplevel state have
            been sent.
            
            This allows changes to the ext_foreign_toplevel_handle_v1 properties
            to be atomically applied. Other protocols which extend the
            ext_foreign_toplevel_handle_v1 interface may use this event to also
            atomically apply any pending state.
            
            This event must not be sent after the ext_foreign_toplevel_handle_v1.closed
            event.
            """
            ...

        # opcode 2
        @staticmethod
        def title(title: string) -> None:
            """
            title change
            
            The title of the toplevel has changed.
            
            The configured state must not be applied immediately. See
            ext_foreign_toplevel_handle_v1.done for details.
            """
            ...

        # opcode 3
        @staticmethod
        def app_id(app_id: string) -> None:
            """
            app_id change
            
            The app id of the toplevel has changed.
            
            The configured state must not be applied immediately. See
            ext_foreign_toplevel_handle_v1.done for details.
            """
            ...

        # opcode 4
        @staticmethod
        def identifier(identifier: string) -> None:
            """
            a stable identifier for a toplevel
            
            This identifier is used to check if two or more toplevel handles belong
            to the same toplevel.
            
            The identifier is useful for command line tools or privileged clients
            which may need to reference an exact toplevel across processes or
            instances of the ext_foreign_toplevel_list_v1 global.
            
            The compositor must only send this event when the handle is created.
            
            The identifier must be unique per toplevel and it's handles. Two different
            toplevels must not have the same identifier. The identifier is only valid
            as long as the toplevel is mapped. If the toplevel is unmapped the identifier
            must not be reused. An identifier must not be reused by the compositor to
            ensure there are no races when sharing identifiers between processes.
            
            An identifier is a string that contains up to 32 printable ASCII bytes.
            An identifier must not be an empty string. It is recommended that a
            compositor includes an opaque generation value in identifiers. How the
            generation value is used when generating the identifier is implementation
            dependent.
            """
            ...

class ext_idle_notifier_v1:
    object_id = 0

    # opcode 0
    @staticmethod
    def destroy() -> None:
        """
        destroy the manager
        
        Destroy the manager object. All objects created via this interface
        remain valid.
        """
        ...

    # opcode 1
    @staticmethod
    def get_idle_notification(timeout: uint, seat: object) -> ext_idle_notification_v1:
        """
        create a notification object
        
        Create a new idle notification object.
        
        The notification object has a minimum timeout duration and is tied to a
        seat. The client will be notified if the seat is inactive for at least
        the provided timeout. See ext_idle_notification_v1 for more details.
        
        A zero timeout is valid and means the client wants to be notified as
        soon as possible when the seat is inactive.
        """
        ...

class ext_idle_notification_v1:
    object_id = 0

    # opcode 0
    @staticmethod
    def destroy() -> None:
        """
        destroy the notification object
        
        Destroy the notification object.
        """
        ...

    class events:
        # opcode 0
        @staticmethod
        def idled() -> None:
            """
            notification object is idle
            
            This event is sent when the notification object becomes idle.
            
            It's a compositor protocol error to send this event twice without a
            resumed event in-between.
            """
            ...

        # opcode 1
        @staticmethod
        def resumed() -> None:
            """
            notification object is no longer idle
            
            This event is sent when the notification object stops being idle.
            
            It's a compositor protocol error to send this event twice without an
            idled event in-between. It's a compositor protocol error to send this
            event prior to any idled event.
            """
            ...

class ext_image_capture_source_v1:
    object_id = 0

    # opcode 0
    @staticmethod
    def destroy() -> None:
        """
        delete this object
        
        Destroys the image capture source. This request may be sent at any time
        by the client.
        """
        ...

class ext_output_image_capture_source_manager_v1:
    object_id = 0

    # opcode 0
    @staticmethod
    def create_source(output: object) -> ext_image_capture_source_v1:
        """
        create source object for output
        
        Creates a source object for an output. Images captured from this source
        will show the same content as the output. Some elements may be omitted,
        such as cursors and overlays that have been marked as transparent to
        capturing.
        """
        ...

    # opcode 1
    @staticmethod
    def destroy() -> None:
        """
        delete this object
        
        Destroys the manager. This request may be sent at any time by the client
        and objects created by the manager will remain valid after its
        destruction.
        """
        ...

class ext_foreign_toplevel_image_capture_source_manager_v1:
    object_id = 0

    # opcode 0
    @staticmethod
    def create_source(toplevel_handle: object) -> ext_image_capture_source_v1:
        """
        create source object for foreign toplevel
        
        Creates a source object for a foreign toplevel handle. Images captured
        from this source will show the same content as the toplevel.
        """
        ...

    # opcode 1
    @staticmethod
    def destroy() -> None:
        """
        delete this object
        
        Destroys the manager. This request may be sent at any time by the client
        and objects created by the manager will remain valid after its
        destruction.
        """
        ...

class ext_image_copy_capture_manager_v1:
    object_id = 0

    # opcode 0
    @staticmethod
    def create_session(source: object, options: uint) -> ext_image_copy_capture_session_v1:
        """
        capture an image capture source
        
        Create a capturing session for an image capture source.
        
        If the paint_cursors option is set, cursors shall be composited onto
        the captured frame. The cursor must not be composited onto the frame
        if this flag is not set.
        
        If the options bitfield is invalid, the invalid_option protocol error
        is sent.
        """
        ...

    # opcode 1
    @staticmethod
    def create_pointer_cursor_session(source: object, pointer: object) -> ext_image_copy_capture_cursor_session_v1:
        """
        capture the pointer cursor of an image capture source
        
        Create a cursor capturing session for the pointer of an image capture
        source.
        """
        ...

    # opcode 2
    @staticmethod
    def destroy() -> None:
        """
        destroy the manager
        
        Destroy the manager object.
        
        Other objects created via this interface are unaffected.
        """
        ...

class ext_image_copy_capture_session_v1:
    object_id = 0

    # opcode 0
    @staticmethod
    def create_frame() -> ext_image_copy_capture_frame_v1:
        """
        create a frame
        
        Create a capture frame for this session.
        
        At most one frame object can exist for a given session at any time. If
        a client sends a create_frame request before a previous frame object
        has been destroyed, the duplicate_frame protocol error is raised.
        """
        ...

    # opcode 1
    @staticmethod
    def destroy() -> None:
        """
        delete this object
        
        Destroys the session. This request can be sent at any time by the
        client.
        
        This request doesn't affect ext_image_copy_capture_frame_v1 objects created by
        this object.
        """
        ...

    class events:
        # opcode 0
        @staticmethod
        def buffer_size(width: uint, height: uint) -> None:
            """
            image capture source dimensions
            
            Provides the dimensions of the source image in buffer pixel coordinates.
            
            The client must attach buffers that match this size.
            """
            ...

        # opcode 1
        @staticmethod
        def shm_format(format: uint) -> None:
            """
            shm buffer format
            
            Provides the format that must be used for shared-memory buffers.
            
            This event may be emitted multiple times, in which case the client may
            choose any given format.
            """
            ...

        # opcode 2
        @staticmethod
        def dmabuf_device(device: array) -> None:
            """
            dma-buf device
            
            This event advertises the device buffers must be allocated on for
            dma-buf buffers.
            
            In general the device is a DRM node. The DRM node type (primary vs.
            render) is unspecified. Clients must not rely on the compositor sending
            a particular node type. Clients cannot check two devices for equality
            by comparing the dev_t value.
            """
            ...

        # opcode 3
        @staticmethod
        def dmabuf_format(format: uint, modifiers: array) -> None:
            """
            dma-buf format
            
            Provides the format that must be used for dma-buf buffers.
            
            The client may choose any of the modifiers advertised in the array of
            64-bit unsigned integers.
            
            This event may be emitted multiple times, in which case the client may
            choose any given format.
            """
            ...

        # opcode 4
        @staticmethod
        def done() -> None:
            """
            all constraints have been sent
            
            This event is sent once when all buffer constraint events have been
            sent.
            
            The compositor must always end a batch of buffer constraint events with
            this event, regardless of whether it sends the initial constraints or
            an update.
            """
            ...

        # opcode 5
        @staticmethod
        def stopped() -> None:
            """
            session is no longer available
            
            This event indicates that the capture session has stopped and is no
            longer available. This can happen in a number of cases, e.g. when the
            underlying source is destroyed, if the user decides to end the image
            capture, or if an unrecoverable runtime error has occurred.
            
            The client should destroy the session after receiving this event.
            """
            ...

class ext_image_copy_capture_frame_v1:
    object_id = 0

    # opcode 0
    @staticmethod
    def destroy() -> None:
        """
        destroy this object
        
        Destroys the session. This request can be sent at any time by the
        client.
        """
        ...

    # opcode 1
    @staticmethod
    def attach_buffer(buffer: object) -> None:
        """
        attach buffer to session
        
        Attach a buffer to the session.
        
        The wl_buffer.release request is unused.
        
        The new buffer replaces any previously attached buffer.
        
        This request must not be sent after capture, or else the
        already_captured protocol error is raised.
        """
        ...

    # opcode 2
    @staticmethod
    def damage_buffer(x: int, y: int, width: int, height: int) -> None:
        """
        damage buffer
        
        Apply damage to the buffer which is to be captured next. This request
        may be sent multiple times to describe a region.
        
        The client indicates the accumulated damage since this wl_buffer was
        last captured. During capture, the compositor will update the buffer
        with at least the union of the region passed by the client and the
        region advertised by ext_image_copy_capture_frame_v1.damage.
        
        When a wl_buffer is captured for the first time, or when the client
        doesn't track damage, the client must damage the whole buffer.
        
        This is for optimisation purposes. The compositor may use this
        information to reduce copying.
        
        These coordinates originate from the upper left corner of the buffer.
        
        If x or y are strictly negative, or if width or height are negative or
        zero, the invalid_buffer_damage protocol error is raised.
        
        This request must not be sent after capture, or else the
        already_captured protocol error is raised.
        """
        ...

    # opcode 3
    @staticmethod
    def capture() -> None:
        """
        capture a frame
        
        Capture a frame.
        
        Unless this is the first successful captured frame performed in this
        session, the compositor may wait an indefinite amount of time for the
        source content to change before performing the copy.
        
        This request may only be sent once, or else the already_captured
        protocol error is raised. A buffer must be attached before this request
        is sent, or else the no_buffer protocol error is raised.
        """
        ...

    class events:
        # opcode 0
        @staticmethod
        def transform(transform: uint) -> None:
            """
            buffer transform
            
            This event is sent before the ready event and holds the transform that
            the compositor has applied to the buffer contents.
            """
            ...

        # opcode 1
        @staticmethod
        def damage(x: int, y: int, width: int, height: int) -> None:
            """
            buffer damaged region
            
            This event is sent before the ready event. It may be generated multiple
            times to describe a region.
            
            The first captured frame in a session will always carry full damage.
            Subsequent frames' damaged regions describe which parts of the buffer
            have changed since the last ready event.
            
            These coordinates originate in the upper left corner of the buffer.
            """
            ...

        # opcode 2
        @staticmethod
        def presentation_time(tv_sec_hi: uint, tv_sec_lo: uint, tv_nsec: uint) -> None:
            """
            presentation time of the frame
            
            This event indicates the time at which the frame is presented to the
            output in system monotonic time. This event is sent before the ready
            event.
            
            The timestamp is expressed as tv_sec_hi, tv_sec_lo, tv_nsec triples,
            each component being an unsigned 32-bit value. Whole seconds are in
            tv_sec which is a 64-bit value combined from tv_sec_hi and tv_sec_lo,
            and the additional fractional part in tv_nsec as nanoseconds. Hence,
            for valid timestamps tv_nsec must be in [0, 999999999].
            """
            ...

        # opcode 3
        @staticmethod
        def ready() -> None:
            """
            frame is available for reading
            
            Called as soon as the frame is copied, indicating it is available
            for reading.
            
            The buffer may be re-used by the client after this event.
            
            After receiving this event, the client must destroy the object.
            """
            ...

        # opcode 4
        @staticmethod
        def failed(reason: uint) -> None:
            """
            capture failed
            
            This event indicates that the attempted frame copy has failed.
            
            After receiving this event, the client must destroy the object.
            """
            ...

class ext_image_copy_capture_cursor_session_v1:
    object_id = 0

    # opcode 0
    @staticmethod
    def destroy() -> None:
        """
        delete this object
        
        Destroys the session. This request can be sent at any time by the
        client.
        
        This request doesn't affect ext_image_copy_capture_frame_v1 objects created by
        this object.
        """
        ...

    # opcode 1
    @staticmethod
    def get_capture_session() -> ext_image_copy_capture_session_v1:
        """
        get image copy captuerer session
        
        Gets the image copy capture session for this cursor session.
        
        The session will produce frames of the cursor image. The compositor may
        pause the session when the cursor leaves the captured area.
        
        This request must not be sent more than once, or else the
        duplicate_session protocol error is raised.
        """
        ...

    class events:
        # opcode 0
        @staticmethod
        def enter() -> None:
            """
            cursor entered captured area
            
            Sent when a cursor enters the captured area. It shall be generated
            before the "position" and "hotspot" events when and only when a cursor
            enters the area.
            
            The cursor enters the captured area when the cursor image intersects
            with the captured area. Note, this is different from e.g.
            wl_pointer.enter.
            """
            ...

        # opcode 1
        @staticmethod
        def leave() -> None:
            """
            cursor left captured area
            
            Sent when a cursor leaves the captured area. No "position" or "hotspot"
            event is generated for the cursor until the cursor enters the captured
            area again.
            """
            ...

        # opcode 2
        @staticmethod
        def position(x: int, y: int) -> None:
            """
            position changed
            
            Cursors outside the image capture source do not get captured and no
            event will be generated for them.
            
            The given position is the position of the cursor's hotspot and it is
            relative to the main buffer's top left corner in transformed buffer
            pixel coordinates. The coordinates may be negative or greater than the
            main buffer size.
            """
            ...

        # opcode 3
        @staticmethod
        def hotspot(x: int, y: int) -> None:
            """
            hotspot changed
            
            The hotspot describes the offset between the cursor image and the
            position of the input device.
            
            The given coordinates are the hotspot's offset from the origin in
            buffer coordinates.
            
            Clients should not apply the hotspot immediately: the hotspot becomes
            effective when the next ext_image_copy_capture_frame_v1.ready event is received.
            
            Compositors may delay this event until the client captures a new frame.
            """
            ...

class ext_session_lock_manager_v1:
    object_id = 0

    # opcode 0
    @staticmethod
    def destroy() -> None:
        """
        destroy the session lock manager object
        
        This informs the compositor that the session lock manager object will
        no longer be used. Existing objects created through this interface
        remain valid.
        """
        ...

    # opcode 1
    @staticmethod
    def lock() -> ext_session_lock_v1:
        """
        attempt to lock the session
        
        This request creates a session lock and asks the compositor to lock the
        session. The compositor will send either the ext_session_lock_v1.locked
        or ext_session_lock_v1.finished event on the created object in
        response to this request.
        """
        ...

class ext_session_lock_v1:
    object_id = 0

    # opcode 0
    @staticmethod
    def destroy() -> None:
        """
        destroy the session lock
        
        This informs the compositor that the lock object will no longer be
        used. Existing objects created through this interface remain valid.
        
        After this request is made, lock surfaces created through this object
        should be destroyed by the client as they will no longer be used by
        the compositor.
        
        It is a protocol error to make this request if the locked event was
        sent, the unlock_and_destroy request must be used instead.
        """
        ...

    # opcode 1
    @staticmethod
    def get_lock_surface(surface: object, output: object) -> ext_session_lock_surface_v1:
        """
        create a lock surface for a given output
        
        The client is expected to create lock surfaces for all outputs
        currently present and any new outputs as they are advertised. These
        won't be displayed by the compositor unless the lock is successful
        and the locked event is sent.
        
        Providing a wl_surface which already has a role or already has a buffer
        attached or committed is a protocol error, as is attaching/committing
        a buffer before the first ext_session_lock_surface_v1.configure event.
        
        Attempting to create more than one lock surface for a given output
        is a duplicate_output protocol error.
        """
        ...

    # opcode 2
    @staticmethod
    def unlock_and_destroy() -> None:
        """
        unlock the session, destroying the object
        
        This request indicates that the session should be unlocked, for
        example because the user has entered their password and it has been
        verified by the client.
        
        This request also informs the compositor that the lock object will
        no longer be used and should be destroyed. Existing objects created
        through this interface remain valid.
        
        After this request is made, lock surfaces created through this object
        should be destroyed by the client as they will no longer be used by
        the compositor.
        
        It is a protocol error to make this request if the locked event has
        not been sent. In that case, the lock object must be destroyed using
        the destroy request.
        
        Note that a correct client that wishes to exit directly after unlocking
        the session must use the wl_display.sync request to ensure the server
        receives and processes the unlock_and_destroy request. Otherwise
        there is no guarantee that the server has unlocked the session due
        to the asynchronous nature of the Wayland protocol. For example,
        the server might terminate the client with a protocol error before
        it processes the unlock_and_destroy request.
        """
        ...

    class events:
        # opcode 0
        @staticmethod
        def locked() -> None:
            """
            session successfully locked
            
            This client is now responsible for displaying graphics while the
            session is locked and deciding when to unlock the session.
            
            The locked event must not be sent until a new "locked" frame has been
            presented on all outputs and no security sensitive normal/unlocked
            content is possibly visible.
            
            If this event is sent, making the destroy request is a protocol error,
            the lock object must be destroyed using the unlock_and_destroy request.
            """
            ...

        # opcode 1
        @staticmethod
        def finished() -> None:
            """
            the session lock object should be destroyed
            
            The compositor has decided that the session lock should be destroyed
            as it will no longer be used by the compositor. Exactly when this
            event is sent is compositor policy, but it must never be sent more
            than once for a given session lock object.
            
            This might be sent because there is already another ext_session_lock_v1
            object held by a client, or the compositor has decided to deny the
            request to lock the session for some other reason. This might also
            be sent because the compositor implements some alternative, secure
            way to authenticate and unlock the session.
            
            The finished event should be sent immediately on creation of this
            object if the compositor decides that the locked event will not
            be sent.
            
            If the locked event is sent on creation of this object the finished
            event may still be sent at some later time in this object's
            lifetime. This is compositor policy.
            
            Upon receiving this event, the client should make either the destroy
            request or the unlock_and_destroy request, depending on whether or
            not the locked event was received on this object.
            """
            ...

class ext_session_lock_surface_v1:
    object_id = 0

    # opcode 0
    @staticmethod
    def destroy() -> None:
        """
        destroy the lock surface object
        
        This informs the compositor that the lock surface object will no
        longer be used.
        
        It is recommended for a lock client to destroy lock surfaces if
        their corresponding wl_output global is removed.
        
        If a lock surface on an active output is destroyed before the
        ext_session_lock_v1.unlock_and_destroy event is sent, the compositor
        must fall back to rendering a solid color.
        """
        ...

    # opcode 1
    @staticmethod
    def ack_configure(serial: uint) -> None:
        """
        ack a configure event
        
        When a configure event is received, if a client commits the surface
        in response to the configure event, then the client must make an
        ack_configure request sometime before the commit request, passing
        along the serial of the configure event.
        
        If the client receives multiple configure events before it can
        respond to one, it only has to ack the last configure event.
        
        A client is not required to commit immediately after sending an
        ack_configure request - it may even ack_configure several times
        before its next surface commit.
        
        A client may send multiple ack_configure requests before committing,
        but only the last request sent before a commit indicates which
        configure event the client really is responding to.
        
        Sending an ack_configure request consumes the configure event
        referenced by the given serial, as well as all older configure events
        sent on this object.
        
        It is a protocol error to issue multiple ack_configure requests
        referencing the same configure event or to issue an ack_configure
        request referencing a configure event older than the last configure
        event acked for a given lock surface.
        """
        ...

    class events:
        # opcode 0
        @staticmethod
        def configure(serial: uint, width: uint, height: uint) -> None:
            """
            the client should resize its surface
            
            This event is sent once on binding the interface and may be sent again
            at the compositor's discretion, for example if output geometry changes.
            
            The width and height are in surface-local coordinates and are exact
            requirements. Failing to match these surface dimensions in the next
            commit after acking a configure is a protocol error.
            """
            ...

class ext_transient_seat_manager_v1:
    object_id = 0

    # opcode 0
    @staticmethod
    def create() -> ext_transient_seat_v1:
        """
        create a transient seat
        
        Create a new seat that is removed when the client side transient seat
        object is destroyed.
        
        The actual seat may be removed sooner, in which case the transient seat
        object shall become inert.
        """
        ...

    # opcode 1
    @staticmethod
    def destroy() -> None:
        """
        destroy the manager
        
        Destroy the manager.
        
        All objects created by the manager will remain valid until they are
        destroyed themselves.
        """
        ...

class ext_transient_seat_v1:
    object_id = 0

    # opcode 0
    @staticmethod
    def destroy() -> None:
        """
        destroy transient seat
        
        When the transient seat object is destroyed by the client, the
        associated seat created by the compositor is also destroyed.
        """
        ...

    class events:
        # opcode 0
        @staticmethod
        def ready(global_name: uint) -> None:
            """
            transient seat is ready
            
            This event advertises the global name for the wl_seat to be used with
            wl_registry_bind.
            
            It is sent exactly once, immediately after the transient seat is created
            and the new "wl_seat" global is advertised, if and only if the creation
            of the transient seat was allowed.
            """
            ...

        # opcode 1
        @staticmethod
        def denied() -> None:
            """
            transient seat creation denied
            
            The event informs the client that the compositor denied its request to
            create a transient seat.
            
            It is sent exactly once, immediately after the transient seat object is
            created, if and only if the creation of the transient seat was denied.
            
            After receiving this event, the client should destroy the object.
            """
            ...

class wp_fractional_scale_manager_v1:
    object_id = 0

    # opcode 0
    @staticmethod
    def destroy() -> None:
        """
        unbind the fractional surface scale interface
        
        Informs the server that the client will not be using this protocol
        object anymore. This does not affect any other objects,
        wp_fractional_scale_v1 objects included.
        """
        ...

    # opcode 1
    @staticmethod
    def get_fractional_scale(surface: object) -> wp_fractional_scale_v1:
        """
        extend surface interface for scale information
        
        Create an add-on object for the the wl_surface to let the compositor
        request fractional scales. If the given wl_surface already has a
        wp_fractional_scale_v1 object associated, the fractional_scale_exists
        protocol error is raised.
        """
        ...

class wp_fractional_scale_v1:
    object_id = 0

    # opcode 0
    @staticmethod
    def destroy() -> None:
        """
        remove surface scale information for surface
        
        Destroy the fractional scale object. When this object is destroyed,
        preferred_scale events will no longer be sent.
        """
        ...

    class events:
        # opcode 0
        @staticmethod
        def preferred_scale(scale: uint) -> None:
            """
            notify of new preferred scale
            
            Notification of a new preferred scale for this surface that the
            compositor suggests that the client should use.
            
            The sent scale is the numerator of a fraction with a denominator of 120.
            """
            ...

class wp_linux_drm_syncobj_manager_v1:
    object_id = 0

    # opcode 0
    @staticmethod
    def destroy() -> None:
        """
        destroy explicit synchronization factory object
        
        Destroy this explicit synchronization factory object. Other objects
        shall not be affected by this request.
        """
        ...

    # opcode 1
    @staticmethod
    def get_surface(surface: object) -> wp_linux_drm_syncobj_surface_v1:
        """
        extend surface interface for explicit synchronization
        
        Instantiate an interface extension for the given wl_surface to provide
        explicit synchronization.
        
        If the given wl_surface already has an explicit synchronization object
        associated, the surface_exists protocol error is raised.
        
        Graphics APIs, like EGL or Vulkan, that manage the buffer queue and
        commits of a wl_surface themselves, are likely to be using this
        extension internally. If a client is using such an API for a
        wl_surface, it should not directly use this extension on that surface,
        to avoid raising a surface_exists protocol error.
        """
        ...

    # opcode 2
    @staticmethod
    def import_timeline(fd: fd) -> wp_linux_drm_syncobj_timeline_v1:
        """
        import a DRM syncobj timeline
        
        Import a DRM synchronization object timeline.
        
        If the FD cannot be imported, the invalid_timeline error is raised.
        """
        ...

class wp_linux_drm_syncobj_timeline_v1:
    object_id = 0

    # opcode 0
    @staticmethod
    def destroy() -> None:
        """
        destroy the timeline
        
        Destroy the synchronization object timeline. Other objects are not
        affected by this request, in particular timeline points set by
        set_acquire_point and set_release_point are not unset.
        """
        ...

class wp_linux_drm_syncobj_surface_v1:
    object_id = 0

    # opcode 0
    @staticmethod
    def destroy() -> None:
        """
        destroy the surface synchronization object
        
        Destroy this surface synchronization object.
        
        Any timeline point set by this object with set_acquire_point or
        set_release_point since the last commit may be discarded by the
        compositor. Any timeline point set by this object before the last
        commit will not be affected.
        """
        ...

    # opcode 1
    @staticmethod
    def set_acquire_point(timeline: object, point_hi: uint, point_lo: uint) -> None:
        """
        set the acquire timeline point
        
        Set the timeline point that must be signalled before the compositor may
        sample from the buffer attached with wl_surface.attach.
        
        The 64-bit unsigned value combined from point_hi and point_lo is the
        point value.
        
        The acquire point is double-buffered state, and will be applied on the
        next wl_surface.commit request for the associated surface. Thus, it
        applies only to the buffer that is attached to the surface at commit
        time.
        
        If an acquire point has already been attached during the same commit
        cycle, the new point replaces the old one.
        
        If the associated wl_surface was destroyed, a no_surface error is
        raised.
        
        If at surface commit time there is a pending acquire timeline point set
        but no pending buffer attached, a no_buffer error is raised. If at
        surface commit time there is a pending buffer attached but no pending
        acquire timeline point set, the no_acquire_point protocol error is
        raised.
        """
        ...

    # opcode 2
    @staticmethod
    def set_release_point(timeline: object, point_hi: uint, point_lo: uint) -> None:
        """
        set the release timeline point
        
        Set the timeline point that must be signalled by the compositor when it
        has finished its usage of the buffer attached with wl_surface.attach
        for the relevant commit.
        
        Once the timeline point is signaled, and assuming the associated buffer
        is not pending release from other wl_surface.commit requests, no
        additional explicit or implicit synchronization with the compositor is
        required to safely re-use the buffer.
        
        Note that clients cannot rely on the release point being always
        signaled after the acquire point: compositors may release buffers
        without ever reading from them. In addition, the compositor may use
        different presentation paths for different commits, which may have
        different release behavior. As a result, the compositor may signal the
        release points in a different order than the client committed them.
        
        Because signaling a timeline point also signals every previous point,
        it is generally not safe to use the same timeline object for the
        release points of multiple buffers. The out-of-order signaling
        described above may lead to a release point being signaled before the
        compositor has finished reading. To avoid this, it is strongly
        recommended that each buffer should use a separate timeline for its
        release points.
        
        The 64-bit unsigned value combined from point_hi and point_lo is the
        point value.
        
        The release point is double-buffered state, and will be applied on the
        next wl_surface.commit request for the associated surface. Thus, it
        applies only to the buffer that is attached to the surface at commit
        time.
        
        If a release point has already been attached during the same commit
        cycle, the new point replaces the old one.
        
        If the associated wl_surface was destroyed, a no_surface error is
        raised.
        
        If at surface commit time there is a pending release timeline point set
        but no pending buffer attached, a no_buffer error is raised. If at
        surface commit time there is a pending buffer attached but no pending
        release timeline point set, the no_release_point protocol error is
        raised.
        """
        ...

class wp_security_context_manager_v1:
    object_id = 0

    # opcode 0
    @staticmethod
    def destroy() -> None:
        """
        destroy the manager object
        
        Destroy the manager. This doesn't destroy objects created with the
        manager.
        """
        ...

    # opcode 1
    @staticmethod
    def create_listener(listen_fd: fd, close_fd: fd) -> wp_security_context_v1:
        """
        create a new security context
        
        Creates a new security context with a socket listening FD.
        
        The compositor will accept new client connections on listen_fd.
        listen_fd must be ready to accept new connections when this request is
        sent by the client. In other words, the client must call bind(2) and
        listen(2) before sending the FD.
        
        close_fd is a FD closed by the client when the compositor should stop
        accepting new connections on listen_fd.
        
        The compositor must continue to accept connections on listen_fd when
        the Wayland client which created the security context disconnects.
        
        After sending this request, closing listen_fd and close_fd remains the
        only valid operation on them.
        """
        ...

class wp_security_context_v1:
    object_id = 0

    # opcode 0
    @staticmethod
    def destroy() -> None:
        """
        destroy the security context object
        
        Destroy the security context object.
        """
        ...

    # opcode 1
    @staticmethod
    def set_sandbox_engine(name: string) -> None:
        """
        set the sandbox engine
        
        Attach a unique sandbox engine name to the security context. The name
        should follow the reverse-DNS style (e.g. "org.flatpak").
        
        A list of well-known engines is maintained at:
        https://gitlab.freedesktop.org/wayland/wayland-protocols/-/blob/main/staging/security-context/engines.md
        
        It is a protocol error to call this request twice. The already_set
        error is sent in this case.
        """
        ...

    # opcode 2
    @staticmethod
    def set_app_id(app_id: string) -> None:
        """
        set the application ID
        
        Attach an application ID to the security context.
        
        The application ID is an opaque, sandbox-specific identifier for an
        application. See the well-known engines document for more details:
        https://gitlab.freedesktop.org/wayland/wayland-protocols/-/blob/main/staging/security-context/engines.md
        
        The compositor may use the application ID to group clients belonging to
        the same security context application.
        
        Whether this request is optional or not depends on the sandbox engine used.
        
        It is a protocol error to call this request twice. The already_set
        error is sent in this case.
        """
        ...

    # opcode 3
    @staticmethod
    def set_instance_id(instance_id: string) -> None:
        """
        set the instance ID
        
        Attach an instance ID to the security context.
        
        The instance ID is an opaque, sandbox-specific identifier for a running
        instance of an application. See the well-known engines document for
        more details:
        https://gitlab.freedesktop.org/wayland/wayland-protocols/-/blob/main/staging/security-context/engines.md
        
        Whether this request is optional or not depends on the sandbox engine used.
        
        It is a protocol error to call this request twice. The already_set
        error is sent in this case.
        """
        ...

    # opcode 4
    @staticmethod
    def commit() -> None:
        """
        register the security context
        
        Atomically register the new client and attach the security context
        metadata.
        
        If the provided metadata is inconsistent or does not match with out of
        band metadata (see
        https://gitlab.freedesktop.org/wayland/wayland-protocols/-/blob/main/staging/security-context/engines.md),
        the invalid_metadata error may be sent eventually.
        
        It's a protocol error to send any request other than "destroy" after
        this request. In this case, the already_used error is sent.
        """
        ...

class wp_single_pixel_buffer_manager_v1:
    object_id = 0

    # opcode 0
    @staticmethod
    def destroy() -> None:
        """
        destroy the manager
        
        Destroy the wp_single_pixel_buffer_manager_v1 object.
        
        The child objects created via this interface are unaffected.
        """
        ...

    # opcode 1
    @staticmethod
    def create_u32_rgba_buffer(r: uint, g: uint, b: uint, a: uint) -> wl_buffer:
        """
        create a 1×1 buffer from 32-bit RGBA values
        
        Create a single-pixel buffer from four 32-bit RGBA values.
        
        Unless specified in another protocol extension, the RGBA values use
        pre-multiplied alpha.
        
        The width and height of the buffer are 1.
        """
        ...

class wp_tearing_control_manager_v1:
    object_id = 0

    # opcode 0
    @staticmethod
    def destroy() -> None:
        """
        destroy tearing control factory object
        
        Destroy this tearing control factory object. Other objects, including
        wp_tearing_control_v1 objects created by this factory, are not affected
        by this request.
        """
        ...

    # opcode 1
    @staticmethod
    def get_tearing_control(surface: object) -> wp_tearing_control_v1:
        """
        extend surface interface for tearing control
        
        Instantiate an interface extension for the given wl_surface to request
        asynchronous page flips for presentation.
        
        If the given wl_surface already has a wp_tearing_control_v1 object
        associated, the tearing_control_exists protocol error is raised.
        """
        ...

class wp_tearing_control_v1:
    object_id = 0

    # opcode 0
    @staticmethod
    def set_presentation_hint(hint: uint) -> None:
        """
        set presentation hint
        
        Set the presentation hint for the associated wl_surface. This state is
        double-buffered, see wl_surface.commit.
        
        The compositor is free to dynamically respect or ignore this hint based
        on various conditions like hardware capabilities, surface state and
        user preferences.
        """
        ...

    # opcode 1
    @staticmethod
    def destroy() -> None:
        """
        destroy tearing control object
        
        Destroy this surface tearing object and revert the presentation hint to
        vsync. The change will be applied on the next wl_surface.commit.
        """
        ...

class xdg_activation_v1:
    object_id = 0

    # opcode 0
    @staticmethod
    def destroy() -> None:
        """
        destroy the xdg_activation object
        
        Notify the compositor that the xdg_activation object will no longer be
        used.
        
        The child objects created via this interface are unaffected and should
        be destroyed separately.
        """
        ...

    # opcode 1
    @staticmethod
    def get_activation_token() -> xdg_activation_token_v1:
        """
        requests a token
        
        Creates an xdg_activation_token_v1 object that will provide
        the initiating client with a unique token for this activation. This
        token should be offered to the clients to be activated.
        """
        ...

    # opcode 2
    @staticmethod
    def activate(token: string, surface: object) -> None:
        """
        notify new interaction being available
        
        Requests surface activation. It's up to the compositor to display
        this information as desired, for example by placing the surface above
        the rest.
        
        The compositor may know who requested this by checking the activation
        token and might decide not to follow through with the activation if it's
        considered unwanted.
        
        Compositors can ignore unknown activation tokens when an invalid
        token is passed.
        """
        ...

class xdg_activation_token_v1:
    object_id = 0

    # opcode 0
    @staticmethod
    def set_serial(serial: uint, seat: object) -> None:
        """
        specifies the seat and serial of the activating event
        
        Provides information about the seat and serial event that requested the
        token.
        
        The serial can come from an input or focus event. For instance, if a
        click triggers the launch of a third-party client, the launcher client
        should send a set_serial request with the serial and seat from the
        wl_pointer.button event.
        
        Some compositors might refuse to activate toplevels when the token
        doesn't have a valid and recent enough event serial.
        
        Must be sent before commit. This information is optional.
        """
        ...

    # opcode 1
    @staticmethod
    def set_app_id(app_id: string) -> None:
        """
        specifies the application being activated
        
        The requesting client can specify an app_id to associate the token
        being created with it.
        
        Must be sent before commit. This information is optional.
        """
        ...

    # opcode 2
    @staticmethod
    def set_surface(surface: object) -> None:
        """
        specifies the surface requesting activation
        
        This request sets the surface requesting the activation. Note, this is
        different from the surface that will be activated.
        
        Some compositors might refuse to activate toplevels when the token
        doesn't have a requesting surface.
        
        Must be sent before commit. This information is optional.
        """
        ...

    # opcode 3
    @staticmethod
    def commit() -> None:
        """
        issues the token request
        
        Requests an activation token based on the different parameters that
        have been offered through set_serial, set_surface and set_app_id.
        """
        ...

    # opcode 4
    @staticmethod
    def destroy() -> None:
        """
        destroy the xdg_activation_token_v1 object
        
        Notify the compositor that the xdg_activation_token_v1 object will no
        longer be used. The received token stays valid.
        """
        ...

    class events:
        # opcode 0
        @staticmethod
        def done(token: string) -> None:
            """
            the exported activation token
            
            The 'done' event contains the unique token of this activation request
            and notifies that the provider is done.
            """
            ...

class xdg_wm_dialog_v1:
    object_id = 0

    # opcode 0
    @staticmethod
    def destroy() -> None:
        """
        destroy the dialog manager object
        
        Destroys the xdg_wm_dialog_v1 object. This does not affect
        the xdg_dialog_v1 objects generated through it.
        """
        ...

    # opcode 1
    @staticmethod
    def get_xdg_dialog(toplevel: object) -> xdg_dialog_v1:
        """
        create a dialog object
        
        Creates a xdg_dialog_v1 object for the given toplevel. See the interface
        description for more details.
        
        Compositors must raise an already_used error if clients attempt to
        create multiple xdg_dialog_v1 objects for the same xdg_toplevel.
        """
        ...

class xdg_dialog_v1:
    object_id = 0

    # opcode 0
    @staticmethod
    def destroy() -> None:
        """
        destroy the dialog object
        
        Destroys the xdg_dialog_v1 object. If this object is destroyed
        before the related xdg_toplevel, the compositor should unapply its
        effects.
        """
        ...

    # opcode 1
    @staticmethod
    def set_modal() -> None:
        """
        mark dialog as modal
        
        Hints that the dialog has "modal" behavior. Modal dialogs typically
        require to be fully addressed by the user (i.e. closed) before resuming
        interaction with the parent toplevel, and may require a distinct
        presentation.
        
        Clients must implement the logic to filter events in the parent
        toplevel on their own.
        
        Compositors may choose any policy in event delivery to the parent
        toplevel, from delivering all events unfiltered to using them for
        internal consumption.
        """
        ...

    # opcode 2
    @staticmethod
    def unset_modal() -> None:
        """
        mark dialog as not modal
        
        Drops the hint that this dialog has "modal" behavior. See
        xdg_dialog_v1.set_modal for more details.
        """
        ...

class xdg_toplevel_drag_manager_v1:
    object_id = 0

    # opcode 0
    @staticmethod
    def destroy() -> None:
        """
        destroy the xdg_toplevel_drag_manager_v1 object
        
        Destroy this xdg_toplevel_drag_manager_v1 object. Other objects,
        including xdg_toplevel_drag_v1 objects created by this factory, are not
        affected by this request.
        """
        ...

    # opcode 1
    @staticmethod
    def get_xdg_toplevel_drag(data_source: object) -> xdg_toplevel_drag_v1:
        """
        get an xdg_toplevel_drag for a wl_data_source
        
        Create an xdg_toplevel_drag for a drag and drop operation that is going
        to be started with data_source.
        
        This request can only be made on sources used in drag-and-drop, so it
        must be performed before wl_data_device.start_drag. Attempting to use
        the source other than for drag-and-drop such as in
        wl_data_device.set_selection will raise an invalid_source error.
        
        Destroying data_source while a toplevel is attached to the
        xdg_toplevel_drag is undefined.
        """
        ...

class xdg_toplevel_drag_v1:
    object_id = 0

    # opcode 0
    @staticmethod
    def destroy() -> None:
        """
        destroy an xdg_toplevel_drag_v1 object
        
        Destroy this xdg_toplevel_drag_v1 object. This request must only be
        called after the underlying wl_data_source drag has ended, as indicated
        by the dnd_drop_performed or cancelled events. In any other case an
        ongoing_drag error is raised.
        """
        ...

    # opcode 1
    @staticmethod
    def attach(toplevel: object, x_offset: int, y_offset: int) -> None:
        """
        Move a toplevel with the drag operation
        
        Request that the window will be moved with the cursor during the drag
        operation. The offset is a hint to the compositor how the toplevel
        should be positioned relative to the cursor hotspot in surface local
        coordinates. For example it might only be used when an unmapped window
        is attached. The attached window does not participate in the selection
        of the drag target.
        
        If the toplevel is unmapped while it is attached, it is automatically
        detached from the drag. In this case this request has to be called again
        if the window should be attached after it is remapped.
        
        This request can be called multiple times but issuing it while a
        toplevel with an active role is attached raises a toplevel_attached
        error.
        """
        ...

class xdg_toplevel_icon_manager_v1:
    object_id = 0

    # opcode 0
    @staticmethod
    def destroy() -> None:
        """
        destroy the toplevel icon manager
        
        Destroy the toplevel icon manager.
        This does not destroy objects created with the manager.
        """
        ...

    # opcode 1
    @staticmethod
    def create_icon() -> xdg_toplevel_icon_v1:
        """
        create a new icon instance
        
        Creates a new icon object. This icon can then be attached to a
        xdg_toplevel via the 'set_icon' request.
        """
        ...

    # opcode 2
    @staticmethod
    def set_icon(toplevel: object, icon: object) -> None:
        """
        set an icon on a toplevel window
        
        This request assigns the icon 'icon' to 'toplevel', or clears the
        toplevel icon if 'icon' was null.
        This state is double-buffered and is applied on the next
        wl_surface.commit of the toplevel.
        
        After making this call, the xdg_toplevel_icon_v1 provided as 'icon'
        can be destroyed by the client without 'toplevel' losing its icon.
        The xdg_toplevel_icon_v1 is immutable from this point, and any
        future attempts to change it must raise the
        'xdg_toplevel_icon_v1.immutable' protocol error.
        
        The compositor must set the toplevel icon from either the pixel data
        the icon provides, or by loading a stock icon using the icon name.
        See the description of 'xdg_toplevel_icon_v1' for details.
        
        If 'icon' is set to null, the icon of the respective toplevel is reset
        to its default icon (usually the icon of the application, derived from
        its desktop-entry file, or a placeholder icon).
        If this request is passed an icon with no pixel buffers or icon name
        assigned, the icon must be reset just like if 'icon' was null.
        """
        ...

    class events:
        # opcode 0
        @staticmethod
        def icon_size(size: int) -> None:
            """
            describes a supported & preferred icon size
            
            This event indicates an icon size the compositor prefers to be
            available if the client has scalable icons and can render to any size.
            
            When the 'xdg_toplevel_icon_manager_v1' object is created, the
            compositor may send one or more 'icon_size' events to describe the list
            of preferred icon sizes. If the compositor has no size preference, it
            may not send any 'icon_size' event, and it is up to the client to
            decide a suitable icon size.
            
            A sequence of 'icon_size' events must be finished with a 'done' event.
            If the compositor has no size preferences, it must still send the
            'done' event, without any preceding 'icon_size' events.
            """
            ...

        # opcode 1
        @staticmethod
        def done() -> None:
            """
            all information has been sent
            
            This event is sent after all 'icon_size' events have been sent.
            """
            ...

class xdg_toplevel_icon_v1:
    object_id = 0

    # opcode 0
    @staticmethod
    def destroy() -> None:
        """
        destroy the icon object
        
        Destroys the 'xdg_toplevel_icon_v1' object.
        The icon must still remain set on every toplevel it was assigned to,
        until the toplevel icon is reset explicitly.
        """
        ...

    # opcode 1
    @staticmethod
    def set_name(icon_name: string) -> None:
        """
        set an icon name
        
        This request assigns an icon name to this icon.
        Any previously set name is overridden.
        
        The compositor must resolve 'icon_name' according to the lookup rules
        described in the XDG icon theme specification[1] using the
        environment's current icon theme.
        
        If the compositor does not support icon names or cannot resolve
        'icon_name' according to the XDG icon theme specification it must
        fall back to using pixel buffer data instead.
        
        If this request is made after the icon has been assigned to a toplevel
        via 'set_icon', a 'immutable' error must be raised.
        
        [1]: https://specifications.freedesktop.org/icon-theme-spec/icon-theme-spec-latest.html
        """
        ...

    # opcode 2
    @staticmethod
    def add_buffer(buffer: object, scale: int) -> None:
        """
        add icon data from a pixel buffer
        
        This request adds pixel data supplied as wl_buffer to the icon.
        
        The client should add pixel data for all icon sizes and scales that
        it can provide, or which are explicitly requested by the compositor
        via 'icon_size' events on xdg_toplevel_icon_manager_v1.
        
        The wl_buffer supplying pixel data as 'buffer' must be backed by wl_shm
        and must be a square (width and height being equal).
        If any of these buffer requirements are not fulfilled, a 'invalid_buffer'
        error must be raised.
        
        If this icon instance already has a buffer of the same size and scale
        from a previous 'add_buffer' request, data from the last request
        overrides the preexisting pixel data.
        
        The wl_buffer must be kept alive for as long as the xdg_toplevel_icon
        it is associated with is not destroyed. The buffer contents must not be
        modified after it was assigned to the icon.
        
        If this request is made after the icon has been assigned to a toplevel
        via 'set_icon', a 'immutable' error must be raised.
        """
        ...

class xwayland_shell_v1:
    object_id = 0

    # opcode 0
    @staticmethod
    def destroy() -> None:
        """
        destroy the Xwayland shell object
        
        Destroy the xwayland_shell_v1 object.
        
        The child objects created via this interface are unaffected.
        """
        ...

    # opcode 1
    @staticmethod
    def get_xwayland_surface(surface: object) -> xwayland_surface_v1:
        """
        assign the xwayland_surface surface role
        
        Create an xwayland_surface_v1 interface for a given wl_surface
        object and gives it the xwayland_surface role.
        
        It is illegal to create an xwayland_surface_v1 for a wl_surface
        which already has an assigned role and this will result in the
        `role` protocol error.
        
        See the documentation of xwayland_surface_v1 for more details
        about what an xwayland_surface_v1 is and how it is used.
        """
        ...

class xwayland_surface_v1:
    object_id = 0

    # opcode 0
    @staticmethod
    def set_serial(serial_lo: uint, serial_hi: uint) -> None:
        """
        associates a Xwayland window to a wl_surface
        
        Associates an Xwayland window to a wl_surface.
        The association state is double-buffered, see wl_surface.commit.
        
        The `serial_lo` and `serial_hi` parameters specify a non-zero
        monotonic serial number which is entirely unique and provided by the
        Xwayland server equal to the serial value provided by a client message
        with a message type of the `WL_SURFACE_SERIAL` atom on the X11 window
        for this surface to be associated to.
        
        The serial value in the `WL_SURFACE_SERIAL` client message is specified
        as having the lo-bits specified in `l[0]` and the hi-bits specified
        in `l[1]`.
        
        If the serial value provided by `serial_lo` and `serial_hi` is not
        valid, the `invalid_serial` protocol error will be raised.
        
        An X11 window may be associated with multiple surfaces throughout its
        lifespan. (eg. unmapping and remapping a window).
        
        For each wl_surface, this state must not be committed more than once,
        otherwise the `already_associated` protocol error will be raised.
        """
        ...

    # opcode 1
    @staticmethod
    def destroy() -> None:
        """
        destroy the Xwayland surface object
        
        Destroy the xwayland_surface_v1 object.
        
        Any already existing associations are unaffected by this action.
        """
        ...

class zwp_linux_dmabuf_v1:
    object_id = 0

    # opcode 0
    @staticmethod
    def destroy() -> None:
        """
        unbind the factory
        
        Objects created through this interface, especially wl_buffers, will
        remain valid.
        """
        ...

    # opcode 1
    @staticmethod
    def create_params() -> zwp_linux_buffer_params_v1:
        """
        create a temporary object for buffer parameters
        
        This temporary object is used to collect multiple dmabuf handles into
        a single batch to create a wl_buffer. It can only be used once and
        should be destroyed after a 'created' or 'failed' event has been
        received.
        """
        ...

    # opcode 2
    @staticmethod
    def get_default_feedback() -> zwp_linux_dmabuf_feedback_v1:
        """
        get default feedback
        
        This request creates a new wp_linux_dmabuf_feedback object not bound
        to a particular surface. This object will deliver feedback about dmabuf
        parameters to use if the client doesn't support per-surface feedback
        (see get_surface_feedback).
        """
        ...

    # opcode 3
    @staticmethod
    def get_surface_feedback(surface: object) -> zwp_linux_dmabuf_feedback_v1:
        """
        get feedback for a surface
        
        This request creates a new wp_linux_dmabuf_feedback object for the
        specified wl_surface. This object will deliver feedback about dmabuf
        parameters to use for buffers attached to this surface.
        
        If the surface is destroyed before the wp_linux_dmabuf_feedback object,
        the feedback object becomes inert.
        """
        ...

    class events:
        # opcode 0
        @staticmethod
        def format(format: uint) -> None:
            """
            supported buffer format
            
            This event advertises one buffer format that the server supports.
            All the supported formats are advertised once when the client
            binds to this interface. A roundtrip after binding guarantees
            that the client has received all supported formats.
            
            For the definition of the format codes, see the
            zwp_linux_buffer_params_v1::create request.
            
            Starting version 4, the format event is deprecated and must not be
            sent by compositors. Instead, use get_default_feedback or
            get_surface_feedback.
            """
            ...

        # opcode 1
        @staticmethod
        def modifier(format: uint, modifier_hi: uint, modifier_lo: uint) -> None:
            """
            supported buffer format modifier
            
            This event advertises the formats that the server supports, along with
            the modifiers supported for each format. All the supported modifiers
            for all the supported formats are advertised once when the client
            binds to this interface. A roundtrip after binding guarantees that
            the client has received all supported format-modifier pairs.
            
            For legacy support, DRM_FORMAT_MOD_INVALID (that is, modifier_hi ==
            0x00ffffff and modifier_lo == 0xffffffff) is allowed in this event.
            It indicates that the server can support the format with an implicit
            modifier. When a plane has DRM_FORMAT_MOD_INVALID as its modifier, it
            is as if no explicit modifier is specified. The effective modifier
            will be derived from the dmabuf.
            
            A compositor that sends valid modifiers and DRM_FORMAT_MOD_INVALID for
            a given format supports both explicit modifiers and implicit modifiers.
            
            For the definition of the format and modifier codes, see the
            zwp_linux_buffer_params_v1::create and zwp_linux_buffer_params_v1::add
            requests.
            
            Starting version 4, the modifier event is deprecated and must not be
            sent by compositors. Instead, use get_default_feedback or
            get_surface_feedback.
            """
            ...

class zwp_linux_buffer_params_v1:
    object_id = 0

    # opcode 0
    @staticmethod
    def destroy() -> None:
        """
        delete this object, used or not
        
        Cleans up the temporary data sent to the server for dmabuf-based
        wl_buffer creation.
        """
        ...

    # opcode 1
    @staticmethod
    def add(fd: fd, plane_idx: uint, offset: uint, stride: uint, modifier_hi: uint, modifier_lo: uint) -> None:
        """
        add a dmabuf to the temporary set
        
        This request adds one dmabuf to the set in this
        zwp_linux_buffer_params_v1.
        
        The 64-bit unsigned value combined from modifier_hi and modifier_lo
        is the dmabuf layout modifier. DRM AddFB2 ioctl calls this the
        fb modifier, which is defined in drm_mode.h of Linux UAPI.
        This is an opaque token. Drivers use this token to express tiling,
        compression, etc. driver-specific modifications to the base format
        defined by the DRM fourcc code.
        
        Starting from version 4, the invalid_format protocol error is sent if
        the format + modifier pair was not advertised as supported.
        
        Starting from version 5, the invalid_format protocol error is sent if
        all planes don't use the same modifier.
        
        This request raises the PLANE_IDX error if plane_idx is too large.
        The error PLANE_SET is raised if attempting to set a plane that
        was already set.
        """
        ...

    # opcode 2
    @staticmethod
    def create(width: int, height: int, format: uint, flags: uint) -> None:
        """
        create a wl_buffer from the given dmabufs
        
        This asks for creation of a wl_buffer from the added dmabuf
        buffers. The wl_buffer is not created immediately but returned via
        the 'created' event if the dmabuf sharing succeeds. The sharing
        may fail at runtime for reasons a client cannot predict, in
        which case the 'failed' event is triggered.
        
        The 'format' argument is a DRM_FORMAT code, as defined by the
        libdrm's drm_fourcc.h. The Linux kernel's DRM sub-system is the
        authoritative source on how the format codes should work.
        
        The 'flags' is a bitfield of the flags defined in enum "flags".
        'y_invert' means the that the image needs to be y-flipped.
        
        Flag 'interlaced' means that the frame in the buffer is not
        progressive as usual, but interlaced. An interlaced buffer as
        supported here must always contain both top and bottom fields.
        The top field always begins on the first pixel row. The temporal
        ordering between the two fields is top field first, unless
        'bottom_first' is specified. It is undefined whether 'bottom_first'
        is ignored if 'interlaced' is not set.
        
        This protocol does not convey any information about field rate,
        duration, or timing, other than the relative ordering between the
        two fields in one buffer. A compositor may have to estimate the
        intended field rate from the incoming buffer rate. It is undefined
        whether the time of receiving wl_surface.commit with a new buffer
        attached, applying the wl_surface state, wl_surface.frame callback
        trigger, presentation, or any other point in the compositor cycle
        is used to measure the frame or field times. There is no support
        for detecting missed or late frames/fields/buffers either, and
        there is no support whatsoever for cooperating with interlaced
        compositor output.
        
        The composited image quality resulting from the use of interlaced
        buffers is explicitly undefined. A compositor may use elaborate
        hardware features or software to deinterlace and create progressive
        output frames from a sequence of interlaced input buffers, or it
        may produce substandard image quality. However, compositors that
        cannot guarantee reasonable image quality in all cases are recommended
        to just reject all interlaced buffers.
        
        Any argument errors, including non-positive width or height,
        mismatch between the number of planes and the format, bad
        format, bad offset or stride, may be indicated by fatal protocol
        errors: INCOMPLETE, INVALID_FORMAT, INVALID_DIMENSIONS,
        OUT_OF_BOUNDS.
        
        Dmabuf import errors in the server that are not obvious client
        bugs are returned via the 'failed' event as non-fatal. This
        allows attempting dmabuf sharing and falling back in the client
        if it fails.
        
        This request can be sent only once in the object's lifetime, after
        which the only legal request is destroy. This object should be
        destroyed after issuing a 'create' request. Attempting to use this
        object after issuing 'create' raises ALREADY_USED protocol error.
        
        It is not mandatory to issue 'create'. If a client wants to
        cancel the buffer creation, it can just destroy this object.
        """
        ...

    # opcode 3
    @staticmethod
    def create_immed(width: int, height: int, format: uint, flags: uint) -> wl_buffer:
        """
        immediately create a wl_buffer from the given                      dmabufs
        
        This asks for immediate creation of a wl_buffer by importing the
        added dmabufs.
        
        In case of import success, no event is sent from the server, and the
        wl_buffer is ready to be used by the client.
        
        Upon import failure, either of the following may happen, as seen fit
        by the implementation:
        - the client is terminated with one of the following fatal protocol
        errors:
        - INCOMPLETE, INVALID_FORMAT, INVALID_DIMENSIONS, OUT_OF_BOUNDS,
        in case of argument errors such as mismatch between the number
        of planes and the format, bad format, non-positive width or
        height, or bad offset or stride.
        - INVALID_WL_BUFFER, in case the cause for failure is unknown or
        platform specific.
        - the server creates an invalid wl_buffer, marks it as failed and
        sends a 'failed' event to the client. The result of using this
        invalid wl_buffer as an argument in any request by the client is
        defined by the compositor implementation.
        
        This takes the same arguments as a 'create' request, and obeys the
        same restrictions.
        """
        ...

    class events:
        # opcode 0
        @staticmethod
        def created(buffer: wl_buffer) -> None:
            """
            buffer creation succeeded
            
            This event indicates that the attempted buffer creation was
            successful. It provides the new wl_buffer referencing the dmabuf(s).
            
            Upon receiving this event, the client should destroy the
            zwp_linux_buffer_params_v1 object.
            """
            ...

        # opcode 1
        @staticmethod
        def failed() -> None:
            """
            buffer creation failed
            
            This event indicates that the attempted buffer creation has
            failed. It usually means that one of the dmabuf constraints
            has not been fulfilled.
            
            Upon receiving this event, the client should destroy the
            zwp_linux_buffer_params_v1 object.
            """
            ...

class zwp_linux_dmabuf_feedback_v1:
    object_id = 0

    # opcode 0
    @staticmethod
    def destroy() -> None:
        """
        destroy the feedback object
        
        Using this request a client can tell the server that it is not going to
        use the wp_linux_dmabuf_feedback object anymore.
        """
        ...

    class events:
        # opcode 0
        @staticmethod
        def done() -> None:
            """
            all feedback has been sent
            
            This event is sent after all parameters of a wp_linux_dmabuf_feedback
            object have been sent.
            
            This allows changes to the wp_linux_dmabuf_feedback parameters to be
            seen as atomic, even if they happen via multiple events.
            """
            ...

        # opcode 1
        @staticmethod
        def format_table(fd: fd, size: uint) -> None:
            """
            format and modifier table
            
            This event provides a file descriptor which can be memory-mapped to
            access the format and modifier table.
            
            The table contains a tightly packed array of consecutive format +
            modifier pairs. Each pair is 16 bytes wide. It contains a format as a
            32-bit unsigned integer, followed by 4 bytes of unused padding, and a
            modifier as a 64-bit unsigned integer. The native endianness is used.
            
            The client must map the file descriptor in read-only private mode.
            
            Compositors are not allowed to mutate the table file contents once this
            event has been sent. Instead, compositors must create a new, separate
            table file and re-send feedback parameters. Compositors are allowed to
            store duplicate format + modifier pairs in the table.
            """
            ...

        # opcode 2
        @staticmethod
        def main_device(device: array) -> None:
            """
            preferred main device
            
            This event advertises the main device that the server prefers to use
            when direct scan-out to the target device isn't possible. The
            advertised main device may be different for each
            wp_linux_dmabuf_feedback object, and may change over time.
            
            There is exactly one main device. The compositor must send at least
            one preference tranche with tranche_target_device equal to main_device.
            
            Clients need to create buffers that the main device can import and
            read from, otherwise creating the dmabuf wl_buffer will fail (see the
            wp_linux_buffer_params.create and create_immed requests for details).
            The main device will also likely be kept active by the compositor,
            so clients can use it instead of waking up another device for power
            savings.
            
            In general the device is a DRM node. The DRM node type (primary vs.
            render) is unspecified. Clients must not rely on the compositor sending
            a particular node type. Clients cannot check two devices for equality
            by comparing the dev_t value.
            
            If explicit modifiers are not supported and the client performs buffer
            allocations on a different device than the main device, then the client
            must force the buffer to have a linear layout.
            """
            ...

        # opcode 3
        @staticmethod
        def tranche_done() -> None:
            """
            a preference tranche has been sent
            
            This event splits tranche_target_device and tranche_formats events in
            preference tranches. It is sent after a set of tranche_target_device
            and tranche_formats events; it represents the end of a tranche. The
            next tranche will have a lower preference.
            """
            ...

        # opcode 4
        @staticmethod
        def tranche_target_device(device: array) -> None:
            """
            target device
            
            This event advertises the target device that the server prefers to use
            for a buffer created given this tranche. The advertised target device
            may be different for each preference tranche, and may change over time.
            
            There is exactly one target device per tranche.
            
            The target device may be a scan-out device, for example if the
            compositor prefers to directly scan-out a buffer created given this
            tranche. The target device may be a rendering device, for example if
            the compositor prefers to texture from said buffer.
            
            The client can use this hint to allocate the buffer in a way that makes
            it accessible from the target device, ideally directly. The buffer must
            still be accessible from the main device, either through direct import
            or through a potentially more expensive fallback path. If the buffer
            can't be directly imported from the main device then clients must be
            prepared for the compositor changing the tranche priority or making
            wl_buffer creation fail (see the wp_linux_buffer_params.create and
            create_immed requests for details).
            
            If the device is a DRM node, the DRM node type (primary vs. render) is
            unspecified. Clients must not rely on the compositor sending a
            particular node type. Clients cannot check two devices for equality by
            comparing the dev_t value.
            
            This event is tied to a preference tranche, see the tranche_done event.
            """
            ...

        # opcode 5
        @staticmethod
        def tranche_formats(indices: array) -> None:
            """
            supported buffer format modifier
            
            This event advertises the format + modifier combinations that the
            compositor supports.
            
            It carries an array of indices, each referring to a format + modifier
            pair in the last received format table (see the format_table event).
            Each index is a 16-bit unsigned integer in native endianness.
            
            For legacy support, DRM_FORMAT_MOD_INVALID is an allowed modifier.
            It indicates that the server can support the format with an implicit
            modifier. When a buffer has DRM_FORMAT_MOD_INVALID as its modifier, it
            is as if no explicit modifier is specified. The effective modifier
            will be derived from the dmabuf.
            
            A compositor that sends valid modifiers and DRM_FORMAT_MOD_INVALID for
            a given format supports both explicit modifiers and implicit modifiers.
            
            Compositors must not send duplicate format + modifier pairs within the
            same tranche or across two different tranches with the same target
            device and flags.
            
            This event is tied to a preference tranche, see the tranche_done event.
            
            For the definition of the format and modifier codes, see the
            wp_linux_buffer_params.create request.
            """
            ...

        # opcode 6
        @staticmethod
        def tranche_flags(flags: uint) -> None:
            """
            tranche flags
            
            This event sets tranche-specific flags.
            
            The scanout flag is a hint that direct scan-out may be attempted by the
            compositor on the target device if the client appropriately allocates a
            buffer. How to allocate a buffer that can be scanned out on the target
            device is implementation-defined.
            
            This event is tied to a preference tranche, see the tranche_done event.
            """
            ...

class wp_presentation:
    object_id = 0

    # opcode 0
    @staticmethod
    def destroy() -> None:
        """
        unbind from the presentation interface
        
        Informs the server that the client will no longer be using
        this protocol object. Existing objects created by this object
        are not affected.
        """
        ...

    # opcode 1
    @staticmethod
    def feedback(surface: object) -> wp_presentation_feedback:
        """
        request presentation feedback information
        
        Request presentation feedback for the current content submission
        on the given surface. This creates a new presentation_feedback
        object, which will deliver the feedback information once. If
        multiple presentation_feedback objects are created for the same
        submission, they will all deliver the same information.
        
        For details on what information is returned, see the
        presentation_feedback interface.
        """
        ...

    class events:
        # opcode 0
        @staticmethod
        def clock_id(clk_id: uint) -> None:
            """
            clock ID for timestamps
            
            This event tells the client in which clock domain the
            compositor interprets the timestamps used by the presentation
            extension. This clock is called the presentation clock.
            
            The compositor sends this event when the client binds to the
            presentation interface. The presentation clock does not change
            during the lifetime of the client connection.
            
            The clock identifier is platform dependent. On POSIX platforms, the
            identifier value is one of the clockid_t values accepted by
            clock_gettime(). clock_gettime() is defined by POSIX.1-2001.
            
            Timestamps in this clock domain are expressed as tv_sec_hi,
            tv_sec_lo, tv_nsec triples, each component being an unsigned
            32-bit value. Whole seconds are in tv_sec which is a 64-bit
            value combined from tv_sec_hi and tv_sec_lo, and the
            additional fractional part in tv_nsec as nanoseconds. Hence,
            for valid timestamps tv_nsec must be in [0, 999999999].
            
            Note that clock_id applies only to the presentation clock,
            and implies nothing about e.g. the timestamps used in the
            Wayland core protocol input events.
            
            Compositors should prefer a clock which does not jump and is
            not slewed e.g. by NTP. The absolute value of the clock is
            irrelevant. Precision of one millisecond or better is
            recommended. Clients must be able to query the current clock
            value directly, not by asking the compositor.
            """
            ...

class wp_presentation_feedback:
    object_id = 0

    class events:
        # opcode 0
        @staticmethod
        def sync_output(output: object) -> None:
            """
            presentation synchronized to this output
            
            As presentation can be synchronized to only one output at a
            time, this event tells which output it was. This event is only
            sent prior to the presented event.
            
            As clients may bind to the same global wl_output multiple
            times, this event is sent for each bound instance that matches
            the synchronized output. If a client has not bound to the
            right wl_output global at all, this event is not sent.
            """
            ...

        # opcode 1
        @staticmethod
        def presented(tv_sec_hi: uint, tv_sec_lo: uint, tv_nsec: uint, refresh: uint, seq_hi: uint, seq_lo: uint, flags: uint) -> None:
            """
            the content update was displayed
            
            The associated content update was displayed to the user at the
            indicated time (tv_sec_hi/lo, tv_nsec). For the interpretation of
            the timestamp, see presentation.clock_id event.
            
            The timestamp corresponds to the time when the content update
            turned into light the first time on the surface's main output.
            Compositors may approximate this from the framebuffer flip
            completion events from the system, and the latency of the
            physical display path if known.
            
            This event is preceded by all related sync_output events
            telling which output's refresh cycle the feedback corresponds
            to, i.e. the main output for the surface. Compositors are
            recommended to choose the output containing the largest part
            of the wl_surface, or keeping the output they previously
            chose. Having a stable presentation output association helps
            clients predict future output refreshes (vblank).
            
            The 'refresh' argument gives the compositor's prediction of how
            many nanoseconds after tv_sec, tv_nsec the very next output
            refresh may occur. This is to further aid clients in
            predicting future refreshes, i.e., estimating the timestamps
            targeting the next few vblanks. If such prediction cannot
            usefully be done, the argument is zero.
            
            If the output does not have a constant refresh rate, explicit
            video mode switches excluded, then the refresh argument must
            be zero.
            
            The 64-bit value combined from seq_hi and seq_lo is the value
            of the output's vertical retrace counter when the content
            update was first scanned out to the display. This value must
            be compatible with the definition of MSC in
            GLX_OML_sync_control specification. Note, that if the display
            path has a non-zero latency, the time instant specified by
            this counter may differ from the timestamp's.
            
            If the output does not have a concept of vertical retrace or a
            refresh cycle, or the output device is self-refreshing without
            a way to query the refresh count, then the arguments seq_hi
            and seq_lo must be zero.
            """
            ...

        # opcode 2
        @staticmethod
        def discarded() -> None:
            """
            the content update was not displayed
            
            The content update was never displayed to the user.
            """
            ...

class zwp_tablet_manager_v2:
    object_id = 0

    # opcode 0
    @staticmethod
    def get_tablet_seat(seat: object) -> zwp_tablet_seat_v2:
        """
        get the tablet seat
        
        Get the wp_tablet_seat object for the given seat. This object
        provides access to all graphics tablets in this seat.
        """
        ...

    # opcode 1
    @staticmethod
    def destroy() -> None:
        """
        release the memory for the tablet manager object
        
        Destroy the wp_tablet_manager object. Objects created from this
        object are unaffected and should be destroyed separately.
        """
        ...

class zwp_tablet_seat_v2:
    object_id = 0

    # opcode 0
    @staticmethod
    def destroy() -> None:
        """
        release the memory for the tablet seat object
        
        Destroy the wp_tablet_seat object. Objects created from this
        object are unaffected and should be destroyed separately.
        """
        ...

    class events:
        # opcode 0
        @staticmethod
        def tablet_added(id: zwp_tablet_v2) -> None:
            """
            new device notification
            
            This event is sent whenever a new tablet becomes available on this
            seat. This event only provides the object id of the tablet, any
            static information about the tablet (device name, vid/pid, etc.) is
            sent through the wp_tablet interface.
            """
            ...

        # opcode 1
        @staticmethod
        def tool_added(id: zwp_tablet_tool_v2) -> None:
            """
            a new tool has been used with a tablet
            
            This event is sent whenever a tool that has not previously been used
            with a tablet comes into use. This event only provides the object id
            of the tool; any static information about the tool (capabilities,
            type, etc.) is sent through the wp_tablet_tool interface.
            """
            ...

        # opcode 2
        @staticmethod
        def pad_added(id: zwp_tablet_pad_v2) -> None:
            """
            new pad notification
            
            This event is sent whenever a new pad is known to the system. Typically,
            pads are physically attached to tablets and a pad_added event is
            sent immediately after the wp_tablet_seat.tablet_added.
            However, some standalone pad devices logically attach to tablets at
            runtime, and the client must wait for wp_tablet_pad.enter to know
            the tablet a pad is attached to.
            
            This event only provides the object id of the pad. All further
            features (buttons, strips, rings) are sent through the wp_tablet_pad
            interface.
            """
            ...

class zwp_tablet_tool_v2:
    object_id = 0

    # opcode 0
    @staticmethod
    def set_cursor(serial: uint, surface: object, hotspot_x: int, hotspot_y: int) -> None:
        """
        set the tablet tool's surface
        
        Sets the surface of the cursor used for this tool on the given
        tablet. This request only takes effect if the tool is in proximity
        of one of the requesting client's surfaces or the surface parameter
        is the current pointer surface. If there was a previous surface set
        with this request it is replaced. If surface is NULL, the cursor
        image is hidden.
        
        The parameters hotspot_x and hotspot_y define the position of the
        pointer surface relative to the pointer location. Its top-left corner
        is always at (x, y) - (hotspot_x, hotspot_y), where (x, y) are the
        coordinates of the pointer location, in surface-local coordinates.
        
        On surface.attach requests to the pointer surface, hotspot_x and
        hotspot_y are decremented by the x and y parameters passed to the
        request. Attach must be confirmed by wl_surface.commit as usual.
        
        The hotspot can also be updated by passing the currently set pointer
        surface to this request with new values for hotspot_x and hotspot_y.
        
        The current and pending input regions of the wl_surface are cleared,
        and wl_surface.set_input_region is ignored until the wl_surface is no
        longer used as the cursor. When the use as a cursor ends, the current
        and pending input regions become undefined, and the wl_surface is
        unmapped.
        
        This request gives the surface the role of a wp_tablet_tool cursor. A
        surface may only ever be used as the cursor surface for one
        wp_tablet_tool. If the surface already has another role or has
        previously been used as cursor surface for a different tool, a
        protocol error is raised.
        """
        ...

    # opcode 1
    @staticmethod
    def destroy() -> None:
        """
        destroy the tool object
        
        This destroys the client's resource for this tool object.
        """
        ...

    class events:
        # opcode 0
        @staticmethod
        def type(tool_type: uint) -> None:
            """
            tool type
            
            The tool type is the high-level type of the tool and usually decides
            the interaction expected from this tool.
            
            This event is sent in the initial burst of events before the
            wp_tablet_tool.done event.
            """
            ...

        # opcode 1
        @staticmethod
        def hardware_serial(hardware_serial_hi: uint, hardware_serial_lo: uint) -> None:
            """
            unique hardware serial number of the tool
            
            If the physical tool can be identified by a unique 64-bit serial
            number, this event notifies the client of this serial number.
            
            If multiple tablets are available in the same seat and the tool is
            uniquely identifiable by the serial number, that tool may move
            between tablets.
            
            Otherwise, if the tool has no serial number and this event is
            missing, the tool is tied to the tablet it first comes into
            proximity with. Even if the physical tool is used on multiple
            tablets, separate wp_tablet_tool objects will be created, one per
            tablet.
            
            This event is sent in the initial burst of events before the
            wp_tablet_tool.done event.
            """
            ...

        # opcode 2
        @staticmethod
        def hardware_id_wacom(hardware_id_hi: uint, hardware_id_lo: uint) -> None:
            """
            hardware id notification in Wacom's format
            
            This event notifies the client of a hardware id available on this tool.
            
            The hardware id is a device-specific 64-bit id that provides extra
            information about the tool in use, beyond the wl_tool.type
            enumeration. The format of the id is specific to tablets made by
            Wacom Inc. For example, the hardware id of a Wacom Grip
            Pen (a stylus) is 0x802.
            
            This event is sent in the initial burst of events before the
            wp_tablet_tool.done event.
            """
            ...

        # opcode 3
        @staticmethod
        def capability(capability: uint) -> None:
            """
            tool capability notification
            
            This event notifies the client of any capabilities of this tool,
            beyond the main set of x/y axes and tip up/down detection.
            
            One event is sent for each extra capability available on this tool.
            
            This event is sent in the initial burst of events before the
            wp_tablet_tool.done event.
            """
            ...

        # opcode 4
        @staticmethod
        def done() -> None:
            """
            tool description events sequence complete
            
            This event signals the end of the initial burst of descriptive
            events. A client may consider the static description of the tool to
            be complete and finalize initialization of the tool.
            """
            ...

        # opcode 5
        @staticmethod
        def removed() -> None:
            """
            tool removed
            
            This event is sent when the tool is removed from the system and will
            send no further events. Should the physical tool come back into
            proximity later, a new wp_tablet_tool object will be created.
            
            It is compositor-dependent when a tool is removed. A compositor may
            remove a tool on proximity out, tablet removal or any other reason.
            A compositor may also keep a tool alive until shutdown.
            
            If the tool is currently in proximity, a proximity_out event will be
            sent before the removed event. See wp_tablet_tool.proximity_out for
            the handling of any buttons logically down.
            
            When this event is received, the client must wp_tablet_tool.destroy
            the object.
            """
            ...

        # opcode 6
        @staticmethod
        def proximity_in(serial: uint, tablet: object, surface: object) -> None:
            """
            proximity in event
            
            Notification that this tool is focused on a certain surface.
            
            This event can be received when the tool has moved from one surface to
            another, or when the tool has come back into proximity above the
            surface.
            
            If any button is logically down when the tool comes into proximity,
            the respective button event is sent after the proximity_in event but
            within the same frame as the proximity_in event.
            """
            ...

        # opcode 7
        @staticmethod
        def proximity_out() -> None:
            """
            proximity out event
            
            Notification that this tool has either left proximity, or is no
            longer focused on a certain surface.
            
            When the tablet tool leaves proximity of the tablet, button release
            events are sent for each button that was held down at the time of
            leaving proximity. These events are sent before the proximity_out
            event but within the same wp_tablet.frame.
            
            If the tool stays within proximity of the tablet, but the focus
            changes from one surface to another, a button release event may not
            be sent until the button is actually released or the tool leaves the
            proximity of the tablet.
            """
            ...

        # opcode 8
        @staticmethod
        def down(serial: uint) -> None:
            """
            tablet tool is making contact
            
            Sent whenever the tablet tool comes in contact with the surface of the
            tablet.
            
            If the tool is already in contact with the tablet when entering the
            input region, the client owning said region will receive a
            wp_tablet.proximity_in event, followed by a wp_tablet.down
            event and a wp_tablet.frame event.
            
            Note that this event describes logical contact, not physical
            contact. On some devices, a compositor may not consider a tool in
            logical contact until a minimum physical pressure threshold is
            exceeded.
            """
            ...

        # opcode 9
        @staticmethod
        def up() -> None:
            """
            tablet tool is no longer making contact
            
            Sent whenever the tablet tool stops making contact with the surface of
            the tablet, or when the tablet tool moves out of the input region
            and the compositor grab (if any) is dismissed.
            
            If the tablet tool moves out of the input region while in contact
            with the surface of the tablet and the compositor does not have an
            ongoing grab on the surface, the client owning said region will
            receive a wp_tablet.up event, followed by a wp_tablet.proximity_out
            event and a wp_tablet.frame event. If the compositor has an ongoing
            grab on this device, this event sequence is sent whenever the grab
            is dismissed in the future.
            
            Note that this event describes logical contact, not physical
            contact. On some devices, a compositor may not consider a tool out
            of logical contact until physical pressure falls below a specific
            threshold.
            """
            ...

        # opcode 10
        @staticmethod
        def motion(x: fixed, y: fixed) -> None:
            """
            motion event
            
            Sent whenever a tablet tool moves.
            """
            ...

        # opcode 11
        @staticmethod
        def pressure(pressure: uint) -> None:
            """
            pressure change event
            
            Sent whenever the pressure axis on a tool changes. The value of this
            event is normalized to a value between 0 and 65535.
            
            Note that pressure may be nonzero even when a tool is not in logical
            contact. See the down and up events for more details.
            """
            ...

        # opcode 12
        @staticmethod
        def distance(distance: uint) -> None:
            """
            distance change event
            
            Sent whenever the distance axis on a tool changes. The value of this
            event is normalized to a value between 0 and 65535.
            
            Note that distance may be nonzero even when a tool is not in logical
            contact. See the down and up events for more details.
            """
            ...

        # opcode 13
        @staticmethod
        def tilt(tilt_x: fixed, tilt_y: fixed) -> None:
            """
            tilt change event
            
            Sent whenever one or both of the tilt axes on a tool change. Each tilt
            value is in degrees, relative to the z-axis of the tablet.
            The angle is positive when the top of a tool tilts along the
            positive x or y axis.
            """
            ...

        # opcode 14
        @staticmethod
        def rotation(degrees: fixed) -> None:
            """
            z-rotation change event
            
            Sent whenever the z-rotation axis on the tool changes. The
            rotation value is in degrees clockwise from the tool's
            logical neutral position.
            """
            ...

        # opcode 15
        @staticmethod
        def slider(position: int) -> None:
            """
            Slider position change event
            
            Sent whenever the slider position on the tool changes. The
            value is normalized between -65535 and 65535, with 0 as the logical
            neutral position of the slider.
            
            The slider is available on e.g. the Wacom Airbrush tool.
            """
            ...

        # opcode 16
        @staticmethod
        def wheel(degrees: fixed, clicks: int) -> None:
            """
            Wheel delta event
            
            Sent whenever the wheel on the tool emits an event. This event
            contains two values for the same axis change. The degrees value is
            in the same orientation as the wl_pointer.vertical_scroll axis. The
            clicks value is in discrete logical clicks of the mouse wheel. This
            value may be zero if the movement of the wheel was less
            than one logical click.
            
            Clients should choose either value and avoid mixing degrees and
            clicks. The compositor may accumulate values smaller than a logical
            click and emulate click events when a certain threshold is met.
            Thus, wl_tablet_tool.wheel events with non-zero clicks values may
            have different degrees values.
            """
            ...

        # opcode 17
        @staticmethod
        def button(serial: uint, button: uint, state: uint) -> None:
            """
            button event
            
            Sent whenever a button on the tool is pressed or released.
            
            If a button is held down when the tool moves in or out of proximity,
            button events are generated by the compositor. See
            wp_tablet_tool.proximity_in and wp_tablet_tool.proximity_out for
            details.
            """
            ...

        # opcode 18
        @staticmethod
        def frame(time: uint) -> None:
            """
            frame event
            
            Marks the end of a series of axis and/or button updates from the
            tablet. The Wayland protocol requires axis updates to be sent
            sequentially, however all events within a frame should be considered
            one hardware event.
            """
            ...

class zwp_tablet_v2:
    object_id = 0

    # opcode 0
    @staticmethod
    def destroy() -> None:
        """
        destroy the tablet object
        
        This destroys the client's resource for this tablet object.
        """
        ...

    class events:
        # opcode 0
        @staticmethod
        def name(name: string) -> None:
            """
            tablet device name
            
            A descriptive name for the tablet device.
            
            If the device has no descriptive name, this event is not sent.
            
            This event is sent in the initial burst of events before the
            wp_tablet.done event.
            """
            ...

        # opcode 1
        @staticmethod
        def id(vid: uint, pid: uint) -> None:
            """
            tablet device USB vendor/product id
            
            The USB vendor and product IDs for the tablet device.
            
            If the device has no USB vendor/product ID, this event is not sent.
            This can happen for virtual devices or non-USB devices, for instance.
            
            This event is sent in the initial burst of events before the
            wp_tablet.done event.
            """
            ...

        # opcode 2
        @staticmethod
        def path(path: string) -> None:
            """
            path to the device
            
            A system-specific device path that indicates which device is behind
            this wp_tablet. This information may be used to gather additional
            information about the device, e.g. through libwacom.
            
            A device may have more than one device path. If so, multiple
            wp_tablet.path events are sent. A device may be emulated and not
            have a device path, and in that case this event will not be sent.
            
            The format of the path is unspecified, it may be a device node, a
            sysfs path, or some other identifier. It is up to the client to
            identify the string provided.
            
            This event is sent in the initial burst of events before the
            wp_tablet.done event.
            """
            ...

        # opcode 3
        @staticmethod
        def done() -> None:
            """
            tablet description events sequence complete
            
            This event is sent immediately to signal the end of the initial
            burst of descriptive events. A client may consider the static
            description of the tablet to be complete and finalize initialization
            of the tablet.
            """
            ...

        # opcode 4
        @staticmethod
        def removed() -> None:
            """
            tablet removed event
            
            Sent when the tablet has been removed from the system. When a tablet
            is removed, some tools may be removed.
            
            When this event is received, the client must wp_tablet.destroy
            the object.
            """
            ...

class zwp_tablet_pad_ring_v2:
    object_id = 0

    # opcode 0
    @staticmethod
    def set_feedback(description: string, serial: uint) -> None:
        """
        set compositor feedback
        
        Request that the compositor use the provided feedback string
        associated with this ring. This request should be issued immediately
        after a wp_tablet_pad_group.mode_switch event from the corresponding
        group is received, or whenever the ring is mapped to a different
        action. See wp_tablet_pad_group.mode_switch for more details.
        
        Clients are encouraged to provide context-aware descriptions for
        the actions associated with the ring; compositors may use this
        information to offer visual feedback about the button layout
        (eg. on-screen displays).
        
        The provided string 'description' is a UTF-8 encoded string to be
        associated with this ring, and is considered user-visible; general
        internationalization rules apply.
        
        The serial argument will be that of the last
        wp_tablet_pad_group.mode_switch event received for the group of this
        ring. Requests providing other serials than the most recent one will be
        ignored.
        """
        ...

    # opcode 1
    @staticmethod
    def destroy() -> None:
        """
        destroy the ring object
        
        This destroys the client's resource for this ring object.
        """
        ...

    class events:
        # opcode 0
        @staticmethod
        def source(source: uint) -> None:
            """
            ring event source
            
            Source information for ring events.
            
            This event does not occur on its own. It is sent before a
            wp_tablet_pad_ring.frame event and carries the source information
            for all events within that frame.
            
            The source specifies how this event was generated. If the source is
            wp_tablet_pad_ring.source.finger, a wp_tablet_pad_ring.stop event
            will be sent when the user lifts the finger off the device.
            
            This event is optional. If the source is unknown for an interaction,
            no event is sent.
            """
            ...

        # opcode 1
        @staticmethod
        def angle(degrees: fixed) -> None:
            """
            angle changed
            
            Sent whenever the angle on a ring changes.
            
            The angle is provided in degrees clockwise from the logical
            north of the ring in the pad's current rotation.
            """
            ...

        # opcode 2
        @staticmethod
        def stop() -> None:
            """
            interaction stopped
            
            Stop notification for ring events.
            
            For some wp_tablet_pad_ring.source types, a wp_tablet_pad_ring.stop
            event is sent to notify a client that the interaction with the ring
            has terminated. This enables the client to implement kinetic scrolling.
            See the wp_tablet_pad_ring.source documentation for information on
            when this event may be generated.
            
            Any wp_tablet_pad_ring.angle events with the same source after this
            event should be considered as the start of a new interaction.
            """
            ...

        # opcode 3
        @staticmethod
        def frame(time: uint) -> None:
            """
            end of a ring event sequence
            
            Indicates the end of a set of ring events that logically belong
            together. A client is expected to accumulate the data in all events
            within the frame before proceeding.
            
            All wp_tablet_pad_ring events before a wp_tablet_pad_ring.frame event belong
            logically together. For example, on termination of a finger interaction
            on a ring the compositor will send a wp_tablet_pad_ring.source event,
            a wp_tablet_pad_ring.stop event and a wp_tablet_pad_ring.frame event.
            
            A wp_tablet_pad_ring.frame event is sent for every logical event
            group, even if the group only contains a single wp_tablet_pad_ring
            event. Specifically, a client may get a sequence: angle, frame,
            angle, frame, etc.
            """
            ...

class zwp_tablet_pad_strip_v2:
    object_id = 0

    # opcode 0
    @staticmethod
    def set_feedback(description: string, serial: uint) -> None:
        """
        set compositor feedback
        
        Requests the compositor to use the provided feedback string
        associated with this strip. This request should be issued immediately
        after a wp_tablet_pad_group.mode_switch event from the corresponding
        group is received, or whenever the strip is mapped to a different
        action. See wp_tablet_pad_group.mode_switch for more details.
        
        Clients are encouraged to provide context-aware descriptions for
        the actions associated with the strip, and compositors may use this
        information to offer visual feedback about the button layout
        (eg. on-screen displays).
        
        The provided string 'description' is a UTF-8 encoded string to be
        associated with this ring, and is considered user-visible; general
        internationalization rules apply.
        
        The serial argument will be that of the last
        wp_tablet_pad_group.mode_switch event received for the group of this
        strip. Requests providing other serials than the most recent one will be
        ignored.
        """
        ...

    # opcode 1
    @staticmethod
    def destroy() -> None:
        """
        destroy the strip object
        
        This destroys the client's resource for this strip object.
        """
        ...

    class events:
        # opcode 0
        @staticmethod
        def source(source: uint) -> None:
            """
            strip event source
            
            Source information for strip events.
            
            This event does not occur on its own. It is sent before a
            wp_tablet_pad_strip.frame event and carries the source information
            for all events within that frame.
            
            The source specifies how this event was generated. If the source is
            wp_tablet_pad_strip.source.finger, a wp_tablet_pad_strip.stop event
            will be sent when the user lifts their finger off the device.
            
            This event is optional. If the source is unknown for an interaction,
            no event is sent.
            """
            ...

        # opcode 1
        @staticmethod
        def position(position: uint) -> None:
            """
            position changed
            
            Sent whenever the position on a strip changes.
            
            The position is normalized to a range of [0, 65535], the 0-value
            represents the top-most and/or left-most position of the strip in
            the pad's current rotation.
            """
            ...

        # opcode 2
        @staticmethod
        def stop() -> None:
            """
            interaction stopped
            
            Stop notification for strip events.
            
            For some wp_tablet_pad_strip.source types, a wp_tablet_pad_strip.stop
            event is sent to notify a client that the interaction with the strip
            has terminated. This enables the client to implement kinetic
            scrolling. See the wp_tablet_pad_strip.source documentation for
            information on when this event may be generated.
            
            Any wp_tablet_pad_strip.position events with the same source after this
            event should be considered as the start of a new interaction.
            """
            ...

        # opcode 3
        @staticmethod
        def frame(time: uint) -> None:
            """
            end of a strip event sequence
            
            Indicates the end of a set of events that represent one logical
            hardware strip event. A client is expected to accumulate the data
            in all events within the frame before proceeding.
            
            All wp_tablet_pad_strip events before a wp_tablet_pad_strip.frame event belong
            logically together. For example, on termination of a finger interaction
            on a strip the compositor will send a wp_tablet_pad_strip.source event,
            a wp_tablet_pad_strip.stop event and a wp_tablet_pad_strip.frame
            event.
            
            A wp_tablet_pad_strip.frame event is sent for every logical event
            group, even if the group only contains a single wp_tablet_pad_strip
            event. Specifically, a client may get a sequence: position, frame,
            position, frame, etc.
            """
            ...

class zwp_tablet_pad_group_v2:
    object_id = 0

    # opcode 0
    @staticmethod
    def destroy() -> None:
        """
        destroy the pad object
        
        Destroy the wp_tablet_pad_group object. Objects created from this object
        are unaffected and should be destroyed separately.
        """
        ...

    class events:
        # opcode 0
        @staticmethod
        def buttons(buttons: array) -> None:
            """
            buttons announced
            
            Sent on wp_tablet_pad_group initialization to announce the available
            buttons in the group. Button indices start at 0, a button may only be
            in one group at a time.
            
            This event is first sent in the initial burst of events before the
            wp_tablet_pad_group.done event.
            
            Some buttons are reserved by the compositor. These buttons may not be
            assigned to any wp_tablet_pad_group. Compositors may broadcast this
            event in the case of changes to the mapping of these reserved buttons.
            If the compositor happens to reserve all buttons in a group, this event
            will be sent with an empty array.
            """
            ...

        # opcode 1
        @staticmethod
        def ring(ring: zwp_tablet_pad_ring_v2) -> None:
            """
            ring announced
            
            Sent on wp_tablet_pad_group initialization to announce available rings.
            One event is sent for each ring available on this pad group.
            
            This event is sent in the initial burst of events before the
            wp_tablet_pad_group.done event.
            """
            ...

        # opcode 2
        @staticmethod
        def strip(strip: zwp_tablet_pad_strip_v2) -> None:
            """
            strip announced
            
            Sent on wp_tablet_pad initialization to announce available strips.
            One event is sent for each strip available on this pad group.
            
            This event is sent in the initial burst of events before the
            wp_tablet_pad_group.done event.
            """
            ...

        # opcode 3
        @staticmethod
        def modes(modes: uint) -> None:
            """
            mode-switch ability announced
            
            Sent on wp_tablet_pad_group initialization to announce that the pad
            group may switch between modes. A client may use a mode to store a
            specific configuration for buttons, rings and strips and use the
            wl_tablet_pad_group.mode_switch event to toggle between these
            configurations. Mode indices start at 0.
            
            Switching modes is compositor-dependent. See the
            wp_tablet_pad_group.mode_switch event for more details.
            
            This event is sent in the initial burst of events before the
            wp_tablet_pad_group.done event. This event is only sent when more than
            more than one mode is available.
            """
            ...

        # opcode 4
        @staticmethod
        def done() -> None:
            """
            tablet group description events sequence complete
            
            This event is sent immediately to signal the end of the initial
            burst of descriptive events. A client may consider the static
            description of the tablet to be complete and finalize initialization
            of the tablet group.
            """
            ...

        # opcode 5
        @staticmethod
        def mode_switch(time: uint, serial: uint, mode: uint) -> None:
            """
            mode switch event
            
            Notification that the mode was switched.
            
            A mode applies to all buttons, rings and strips in a group
            simultaneously, but a client is not required to assign different actions
            for each mode. For example, a client may have mode-specific button
            mappings but map the ring to vertical scrolling in all modes. Mode
            indices start at 0.
            
            Switching modes is compositor-dependent. The compositor may provide
            visual cues to the client about the mode, e.g. by toggling LEDs on
            the tablet device. Mode-switching may be software-controlled or
            controlled by one or more physical buttons. For example, on a Wacom
            Intuos Pro, the button inside the ring may be assigned to switch
            between modes.
            
            The compositor will also send this event after wp_tablet_pad.enter on
            each group in order to notify of the current mode. Groups that only
            feature one mode will use mode=0 when emitting this event.
            
            If a button action in the new mode differs from the action in the
            previous mode, the client should immediately issue a
            wp_tablet_pad.set_feedback request for each changed button.
            
            If a ring or strip action in the new mode differs from the action
            in the previous mode, the client should immediately issue a
            wp_tablet_ring.set_feedback or wp_tablet_strip.set_feedback request
            for each changed ring or strip.
            """
            ...

class zwp_tablet_pad_v2:
    object_id = 0

    # opcode 0
    @staticmethod
    def set_feedback(button: uint, description: string, serial: uint) -> None:
        """
        set compositor feedback
        
        Requests the compositor to use the provided feedback string
        associated with this button. This request should be issued immediately
        after a wp_tablet_pad_group.mode_switch event from the corresponding
        group is received, or whenever a button is mapped to a different
        action. See wp_tablet_pad_group.mode_switch for more details.
        
        Clients are encouraged to provide context-aware descriptions for
        the actions associated with each button, and compositors may use
        this information to offer visual feedback on the button layout
        (e.g. on-screen displays).
        
        Button indices start at 0. Setting the feedback string on a button
        that is reserved by the compositor (i.e. not belonging to any
        wp_tablet_pad_group) does not generate an error but the compositor
        is free to ignore the request.
        
        The provided string 'description' is a UTF-8 encoded string to be
        associated with this ring, and is considered user-visible; general
        internationalization rules apply.
        
        The serial argument will be that of the last
        wp_tablet_pad_group.mode_switch event received for the group of this
        button. Requests providing other serials than the most recent one will
        be ignored.
        """
        ...

    # opcode 1
    @staticmethod
    def destroy() -> None:
        """
        destroy the pad object
        
        Destroy the wp_tablet_pad object. Objects created from this object
        are unaffected and should be destroyed separately.
        """
        ...

    class events:
        # opcode 0
        @staticmethod
        def group(pad_group: zwp_tablet_pad_group_v2) -> None:
            """
            group announced
            
            Sent on wp_tablet_pad initialization to announce available groups.
            One event is sent for each pad group available.
            
            This event is sent in the initial burst of events before the
            wp_tablet_pad.done event. At least one group will be announced.
            """
            ...

        # opcode 1
        @staticmethod
        def path(path: string) -> None:
            """
            path to the device
            
            A system-specific device path that indicates which device is behind
            this wp_tablet_pad. This information may be used to gather additional
            information about the device, e.g. through libwacom.
            
            The format of the path is unspecified, it may be a device node, a
            sysfs path, or some other identifier. It is up to the client to
            identify the string provided.
            
            This event is sent in the initial burst of events before the
            wp_tablet_pad.done event.
            """
            ...

        # opcode 2
        @staticmethod
        def buttons(buttons: uint) -> None:
            """
            buttons announced
            
            Sent on wp_tablet_pad initialization to announce the available
            buttons.
            
            This event is sent in the initial burst of events before the
            wp_tablet_pad.done event. This event is only sent when at least one
            button is available.
            """
            ...

        # opcode 3
        @staticmethod
        def done() -> None:
            """
            pad description event sequence complete
            
            This event signals the end of the initial burst of descriptive
            events. A client may consider the static description of the pad to
            be complete and finalize initialization of the pad.
            """
            ...

        # opcode 4
        @staticmethod
        def button(time: uint, button: uint, state: uint) -> None:
            """
            physical button state
            
            Sent whenever the physical state of a button changes.
            """
            ...

        # opcode 5
        @staticmethod
        def enter(serial: uint, tablet: object, surface: object) -> None:
            """
            enter event
            
            Notification that this pad is focused on the specified surface.
            """
            ...

        # opcode 6
        @staticmethod
        def leave(serial: uint, surface: object) -> None:
            """
            leave event
            
            Notification that this pad is no longer focused on the specified
            surface.
            """
            ...

        # opcode 7
        @staticmethod
        def removed() -> None:
            """
            pad removed event
            
            Sent when the pad has been removed from the system. When a tablet
            is removed its pad(s) will be removed too.
            
            When this event is received, the client must destroy all rings, strips
            and groups that were offered by this pad, and issue wp_tablet_pad.destroy
            the pad itself.
            """
            ...

class wp_viewporter:
    object_id = 0

    # opcode 0
    @staticmethod
    def destroy() -> None:
        """
        unbind from the cropping and scaling interface
        
        Informs the server that the client will not be using this
        protocol object anymore. This does not affect any other objects,
        wp_viewport objects included.
        """
        ...

    # opcode 1
    @staticmethod
    def get_viewport(surface: object) -> wp_viewport:
        """
        extend surface interface for crop and scale
        
        Instantiate an interface extension for the given wl_surface to
        crop and scale its content. If the given wl_surface already has
        a wp_viewport object associated, the viewport_exists
        protocol error is raised.
        """
        ...

class wp_viewport:
    object_id = 0

    # opcode 0
    @staticmethod
    def destroy() -> None:
        """
        remove scaling and cropping from the surface
        
        The associated wl_surface's crop and scale state is removed.
        The change is applied on the next wl_surface.commit.
        """
        ...

    # opcode 1
    @staticmethod
    def set_source(x: fixed, y: fixed, width: fixed, height: fixed) -> None:
        """
        set the source rectangle for cropping
        
        Set the source rectangle of the associated wl_surface. See
        wp_viewport for the description, and relation to the wl_buffer
        size.
        
        If all of x, y, width and height are -1.0, the source rectangle is
        unset instead. Any other set of values where width or height are zero
        or negative, or x or y are negative, raise the bad_value protocol
        error.
        
        The crop and scale state is double-buffered, see wl_surface.commit.
        """
        ...

    # opcode 2
    @staticmethod
    def set_destination(width: int, height: int) -> None:
        """
        set the surface size for scaling
        
        Set the destination size of the associated wl_surface. See
        wp_viewport for the description, and relation to the wl_buffer
        size.
        
        If width is -1 and height is -1, the destination size is unset
        instead. Any other pair of values for width and height that
        contains zero or negative values raises the bad_value protocol
        error.
        
        The crop and scale state is double-buffered, see wl_surface.commit.
        """
        ...

class xdg_wm_base:
    object_id = 0

    # opcode 0
    @staticmethod
    def destroy() -> None:
        """
        destroy xdg_wm_base
        
        Destroy this xdg_wm_base object.
        
        Destroying a bound xdg_wm_base object while there are surfaces
        still alive created by this xdg_wm_base object instance is illegal
        and will result in a defunct_surfaces error.
        """
        ...

    # opcode 1
    @staticmethod
    def create_positioner() -> xdg_positioner:
        """
        create a positioner object
        
        Create a positioner object. A positioner object is used to position
        surfaces relative to some parent surface. See the interface description
        and xdg_surface.get_popup for details.
        """
        ...

    # opcode 2
    @staticmethod
    def get_xdg_surface(surface: object) -> xdg_surface:
        """
        create a shell surface from a surface
        
        This creates an xdg_surface for the given surface. While xdg_surface
        itself is not a role, the corresponding surface may only be assigned
        a role extending xdg_surface, such as xdg_toplevel or xdg_popup. It is
        illegal to create an xdg_surface for a wl_surface which already has an
        assigned role and this will result in a role error.
        
        This creates an xdg_surface for the given surface. An xdg_surface is
        used as basis to define a role to a given surface, such as xdg_toplevel
        or xdg_popup. It also manages functionality shared between xdg_surface
        based surface roles.
        
        See the documentation of xdg_surface for more details about what an
        xdg_surface is and how it is used.
        """
        ...

    # opcode 3
    @staticmethod
    def pong(serial: uint) -> None:
        """
        respond to a ping event
        
        A client must respond to a ping event with a pong request or
        the client may be deemed unresponsive. See xdg_wm_base.ping
        and xdg_wm_base.error.unresponsive.
        """
        ...

    class events:
        # opcode 0
        @staticmethod
        def ping(serial: uint) -> None:
            """
            check if the client is alive
            
            The ping event asks the client if it's still alive. Pass the
            serial specified in the event back to the compositor by sending
            a "pong" request back with the specified serial. See xdg_wm_base.pong.
            
            Compositors can use this to determine if the client is still
            alive. It's unspecified what will happen if the client doesn't
            respond to the ping request, or in what timeframe. Clients should
            try to respond in a reasonable amount of time. The “unresponsive”
            error is provided for compositors that wish to disconnect unresponsive
            clients.
            
            A compositor is free to ping in any way it wants, but a client must
            always respond to any xdg_wm_base object it created.
            """
            ...

class xdg_positioner:
    object_id = 0

    # opcode 0
    @staticmethod
    def destroy() -> None:
        """
        destroy the xdg_positioner object
        
        Notify the compositor that the xdg_positioner will no longer be used.
        """
        ...

    # opcode 1
    @staticmethod
    def set_size(width: int, height: int) -> None:
        """
        set the size of the to-be positioned rectangle
        
        Set the size of the surface that is to be positioned with the positioner
        object. The size is in surface-local coordinates and corresponds to the
        window geometry. See xdg_surface.set_window_geometry.
        
        If a zero or negative size is set the invalid_input error is raised.
        """
        ...

    # opcode 2
    @staticmethod
    def set_anchor_rect(x: int, y: int, width: int, height: int) -> None:
        """
        set the anchor rectangle within the parent surface
        
        Specify the anchor rectangle within the parent surface that the child
        surface will be placed relative to. The rectangle is relative to the
        window geometry as defined by xdg_surface.set_window_geometry of the
        parent surface.
        
        When the xdg_positioner object is used to position a child surface, the
        anchor rectangle may not extend outside the window geometry of the
        positioned child's parent surface.
        
        If a negative size is set the invalid_input error is raised.
        """
        ...

    # opcode 3
    @staticmethod
    def set_anchor(anchor: uint) -> None:
        """
        set anchor rectangle anchor
        
        Defines the anchor point for the anchor rectangle. The specified anchor
        is used derive an anchor point that the child surface will be
        positioned relative to. If a corner anchor is set (e.g. 'top_left' or
        'bottom_right'), the anchor point will be at the specified corner;
        otherwise, the derived anchor point will be centered on the specified
        edge, or in the center of the anchor rectangle if no edge is specified.
        """
        ...

    # opcode 4
    @staticmethod
    def set_gravity(gravity: uint) -> None:
        """
        set child surface gravity
        
        Defines in what direction a surface should be positioned, relative to
        the anchor point of the parent surface. If a corner gravity is
        specified (e.g. 'bottom_right' or 'top_left'), then the child surface
        will be placed towards the specified gravity; otherwise, the child
        surface will be centered over the anchor point on any axis that had no
        gravity specified. If the gravity is not in the ‘gravity’ enum, an
        invalid_input error is raised.
        """
        ...

    # opcode 5
    @staticmethod
    def set_constraint_adjustment(constraint_adjustment: uint) -> None:
        """
        set the adjustment to be done when constrained
        
        Specify how the window should be positioned if the originally intended
        position caused the surface to be constrained, meaning at least
        partially outside positioning boundaries set by the compositor. The
        adjustment is set by constructing a bitmask describing the adjustment to
        be made when the surface is constrained on that axis.
        
        If no bit for one axis is set, the compositor will assume that the child
        surface should not change its position on that axis when constrained.
        
        If more than one bit for one axis is set, the order of how adjustments
        are applied is specified in the corresponding adjustment descriptions.
        
        The default adjustment is none.
        """
        ...

    # opcode 6
    @staticmethod
    def set_offset(x: int, y: int) -> None:
        """
        set surface position offset
        
        Specify the surface position offset relative to the position of the
        anchor on the anchor rectangle and the anchor on the surface. For
        example if the anchor of the anchor rectangle is at (x, y), the surface
        has the gravity bottom|right, and the offset is (ox, oy), the calculated
        surface position will be (x + ox, y + oy). The offset position of the
        surface is the one used for constraint testing. See
        set_constraint_adjustment.
        
        An example use case is placing a popup menu on top of a user interface
        element, while aligning the user interface element of the parent surface
        with some user interface element placed somewhere in the popup surface.
        """
        ...

    # opcode 7
    @staticmethod
    def set_reactive() -> None:
        """
        continuously reconstrain the surface
        
        When set reactive, the surface is reconstrained if the conditions used
        for constraining changed, e.g. the parent window moved.
        
        If the conditions changed and the popup was reconstrained, an
        xdg_popup.configure event is sent with updated geometry, followed by an
        xdg_surface.configure event.
        """
        ...

    # opcode 8
    @staticmethod
    def set_parent_size(parent_width: int, parent_height: int) -> None:
        """
        
        
        Set the parent window geometry the compositor should use when
        positioning the popup. The compositor may use this information to
        determine the future state the popup should be constrained using. If
        this doesn't match the dimension of the parent the popup is eventually
        positioned against, the behavior is undefined.
        
        The arguments are given in the surface-local coordinate space.
        """
        ...

    # opcode 9
    @staticmethod
    def set_parent_configure(serial: uint) -> None:
        """
        set parent configure this is a response to
        
        Set the serial of an xdg_surface.configure event this positioner will be
        used in response to. The compositor may use this information together
        with set_parent_size to determine what future state the popup should be
        constrained using.
        """
        ...

class xdg_surface:
    object_id = 0

    # opcode 0
    @staticmethod
    def destroy() -> None:
        """
        destroy the xdg_surface
        
        Destroy the xdg_surface object. An xdg_surface must only be destroyed
        after its role object has been destroyed, otherwise
        a defunct_role_object error is raised.
        """
        ...

    # opcode 1
    @staticmethod
    def get_toplevel() -> xdg_toplevel:
        """
        assign the xdg_toplevel surface role
        
        This creates an xdg_toplevel object for the given xdg_surface and gives
        the associated wl_surface the xdg_toplevel role.
        
        See the documentation of xdg_toplevel for more details about what an
        xdg_toplevel is and how it is used.
        """
        ...

    # opcode 2
    @staticmethod
    def get_popup(parent: object, positioner: object) -> xdg_popup:
        """
        assign the xdg_popup surface role
        
        This creates an xdg_popup object for the given xdg_surface and gives
        the associated wl_surface the xdg_popup role.
        
        If null is passed as a parent, a parent surface must be specified using
        some other protocol, before committing the initial state.
        
        See the documentation of xdg_popup for more details about what an
        xdg_popup is and how it is used.
        """
        ...

    # opcode 3
    @staticmethod
    def set_window_geometry(x: int, y: int, width: int, height: int) -> None:
        """
        set the new window geometry
        
        The window geometry of a surface is its "visible bounds" from the
        user's perspective. Client-side decorations often have invisible
        portions like drop-shadows which should be ignored for the
        purposes of aligning, placing and constraining windows.
        
        The window geometry is double-buffered state, see wl_surface.commit.
        
        When maintaining a position, the compositor should treat the (x, y)
        coordinate of the window geometry as the top left corner of the window.
        A client changing the (x, y) window geometry coordinate should in
        general not alter the position of the window.
        
        Once the window geometry of the surface is set, it is not possible to
        unset it, and it will remain the same until set_window_geometry is
        called again, even if a new subsurface or buffer is attached.
        
        If never set, the value is the full bounds of the surface,
        including any subsurfaces. This updates dynamically on every
        commit. This unset is meant for extremely simple clients.
        
        The arguments are given in the surface-local coordinate space of
        the wl_surface associated with this xdg_surface, and may extend outside
        of the wl_surface itself to mark parts of the subsurface tree as part of
        the window geometry.
        
        When applied, the effective window geometry will be the set window
        geometry clamped to the bounding rectangle of the combined
        geometry of the surface of the xdg_surface and the associated
        subsurfaces.
        
        The effective geometry will not be recalculated unless a new call to
        set_window_geometry is done and the new pending surface state is
        subsequently applied.
        
        The width and height of the effective window geometry must be
        greater than zero. Setting an invalid size will raise an
        invalid_size error.
        """
        ...

    # opcode 4
    @staticmethod
    def ack_configure(serial: uint) -> None:
        """
        ack a configure event
        
        When a configure event is received, if a client commits the
        surface in response to the configure event, then the client
        must make an ack_configure request sometime before the commit
        request, passing along the serial of the configure event.
        
        For instance, for toplevel surfaces the compositor might use this
        information to move a surface to the top left only when the client has
        drawn itself for the maximized or fullscreen state.
        
        If the client receives multiple configure events before it
        can respond to one, it only has to ack the last configure event.
        Acking a configure event that was never sent raises an invalid_serial
        error.
        
        A client is not required to commit immediately after sending
        an ack_configure request - it may even ack_configure several times
        before its next surface commit.
        
        A client may send multiple ack_configure requests before committing, but
        only the last request sent before a commit indicates which configure
        event the client really is responding to.
        
        Sending an ack_configure request consumes the serial number sent with
        the request, as well as serial numbers sent by all configure events
        sent on this xdg_surface prior to the configure event referenced by
        the committed serial.
        
        It is an error to issue multiple ack_configure requests referencing a
        serial from the same configure event, or to issue an ack_configure
        request referencing a serial from a configure event issued before the
        event identified by the last ack_configure request for the same
        xdg_surface. Doing so will raise an invalid_serial error.
        """
        ...

    class events:
        # opcode 0
        @staticmethod
        def configure(serial: uint) -> None:
            """
            suggest a surface change
            
            The configure event marks the end of a configure sequence. A configure
            sequence is a set of one or more events configuring the state of the
            xdg_surface, including the final xdg_surface.configure event.
            
            Where applicable, xdg_surface surface roles will during a configure
            sequence extend this event as a latched state sent as events before the
            xdg_surface.configure event. Such events should be considered to make up
            a set of atomically applied configuration states, where the
            xdg_surface.configure commits the accumulated state.
            
            Clients should arrange their surface for the new states, and then send
            an ack_configure request with the serial sent in this configure event at
            some point before committing the new surface.
            
            If the client receives multiple configure events before it can respond
            to one, it is free to discard all but the last event it received.
            """
            ...

class xdg_toplevel:
    object_id = 0

    # opcode 0
    @staticmethod
    def destroy() -> None:
        """
        destroy the xdg_toplevel
        
        This request destroys the role surface and unmaps the surface;
        see "Unmapping" behavior in interface section for details.
        """
        ...

    # opcode 1
    @staticmethod
    def set_parent(parent: object) -> None:
        """
        set the parent of this surface
        
        Set the "parent" of this surface. This surface should be stacked
        above the parent surface and all other ancestor surfaces.
        
        Parent surfaces should be set on dialogs, toolboxes, or other
        "auxiliary" surfaces, so that the parent is raised when the dialog
        is raised.
        
        Setting a null parent for a child surface unsets its parent. Setting
        a null parent for a surface which currently has no parent is a no-op.
        
        Only mapped surfaces can have child surfaces. Setting a parent which
        is not mapped is equivalent to setting a null parent. If a surface
        becomes unmapped, its children's parent is set to the parent of
        the now-unmapped surface. If the now-unmapped surface has no parent,
        its children's parent is unset. If the now-unmapped surface becomes
        mapped again, its parent-child relationship is not restored.
        
        The parent toplevel must not be one of the child toplevel's
        descendants, and the parent must be different from the child toplevel,
        otherwise the invalid_parent protocol error is raised.
        """
        ...

    # opcode 2
    @staticmethod
    def set_title(title: string) -> None:
        """
        set surface title
        
        Set a short title for the surface.
        
        This string may be used to identify the surface in a task bar,
        window list, or other user interface elements provided by the
        compositor.
        
        The string must be encoded in UTF-8.
        """
        ...

    # opcode 3
    @staticmethod
    def set_app_id(app_id: string) -> None:
        """
        set application ID
        
        Set an application identifier for the surface.
        
        The app ID identifies the general class of applications to which
        the surface belongs. The compositor can use this to group multiple
        surfaces together, or to determine how to launch a new application.
        
        For D-Bus activatable applications, the app ID is used as the D-Bus
        service name.
        
        The compositor shell will try to group application surfaces together
        by their app ID. As a best practice, it is suggested to select app
        ID's that match the basename of the application's .desktop file.
        For example, "org.freedesktop.FooViewer" where the .desktop file is
        "org.freedesktop.FooViewer.desktop".
        
        Like other properties, a set_app_id request can be sent after the
        xdg_toplevel has been mapped to update the property.
        
        See the desktop-entry specification [0] for more details on
        application identifiers and how they relate to well-known D-Bus
        names and .desktop files.
        
        [0] https://standards.freedesktop.org/desktop-entry-spec/
        """
        ...

    # opcode 4
    @staticmethod
    def show_window_menu(seat: object, serial: uint, x: int, y: int) -> None:
        """
        show the window menu
        
        Clients implementing client-side decorations might want to show
        a context menu when right-clicking on the decorations, giving the
        user a menu that they can use to maximize or minimize the window.
        
        This request asks the compositor to pop up such a window menu at
        the given position, relative to the local surface coordinates of
        the parent surface. There are no guarantees as to what menu items
        the window menu contains, or even if a window menu will be drawn
        at all.
        
        This request must be used in response to some sort of user action
        like a button press, key press, or touch down event.
        """
        ...

    # opcode 5
    @staticmethod
    def move(seat: object, serial: uint) -> None:
        """
        start an interactive move
        
        Start an interactive, user-driven move of the surface.
        
        This request must be used in response to some sort of user action
        like a button press, key press, or touch down event. The passed
        serial is used to determine the type of interactive move (touch,
        pointer, etc).
        
        The server may ignore move requests depending on the state of
        the surface (e.g. fullscreen or maximized), or if the passed serial
        is no longer valid.
        
        If triggered, the surface will lose the focus of the device
        (wl_pointer, wl_touch, etc) used for the move. It is up to the
        compositor to visually indicate that the move is taking place, such as
        updating a pointer cursor, during the move. There is no guarantee
        that the device focus will return when the move is completed.
        """
        ...

    # opcode 6
    @staticmethod
    def resize(seat: object, serial: uint, edges: uint) -> None:
        """
        start an interactive resize
        
        Start a user-driven, interactive resize of the surface.
        
        This request must be used in response to some sort of user action
        like a button press, key press, or touch down event. The passed
        serial is used to determine the type of interactive resize (touch,
        pointer, etc).
        
        The server may ignore resize requests depending on the state of
        the surface (e.g. fullscreen or maximized).
        
        If triggered, the client will receive configure events with the
        "resize" state enum value and the expected sizes. See the "resize"
        enum value for more details about what is required. The client
        must also acknowledge configure events using "ack_configure". After
        the resize is completed, the client will receive another "configure"
        event without the resize state.
        
        If triggered, the surface also will lose the focus of the device
        (wl_pointer, wl_touch, etc) used for the resize. It is up to the
        compositor to visually indicate that the resize is taking place,
        such as updating a pointer cursor, during the resize. There is no
        guarantee that the device focus will return when the resize is
        completed.
        
        The edges parameter specifies how the surface should be resized, and
        is one of the values of the resize_edge enum. Values not matching
        a variant of the enum will cause the invalid_resize_edge protocol error.
        The compositor may use this information to update the surface position
        for example when dragging the top left corner. The compositor may also
        use this information to adapt its behavior, e.g. choose an appropriate
        cursor image.
        """
        ...

    # opcode 7
    @staticmethod
    def set_max_size(width: int, height: int) -> None:
        """
        set the maximum size
        
        Set a maximum size for the window.
        
        The client can specify a maximum size so that the compositor does
        not try to configure the window beyond this size.
        
        The width and height arguments are in window geometry coordinates.
        See xdg_surface.set_window_geometry.
        
        Values set in this way are double-buffered, see wl_surface.commit.
        
        The compositor can use this information to allow or disallow
        different states like maximize or fullscreen and draw accurate
        animations.
        
        Similarly, a tiling window manager may use this information to
        place and resize client windows in a more effective way.
        
        The client should not rely on the compositor to obey the maximum
        size. The compositor may decide to ignore the values set by the
        client and request a larger size.
        
        If never set, or a value of zero in the request, means that the
        client has no expected maximum size in the given dimension.
        As a result, a client wishing to reset the maximum size
        to an unspecified state can use zero for width and height in the
        request.
        
        Requesting a maximum size to be smaller than the minimum size of
        a surface is illegal and will result in an invalid_size error.
        
        The width and height must be greater than or equal to zero. Using
        strictly negative values for width or height will result in a
        invalid_size error.
        """
        ...

    # opcode 8
    @staticmethod
    def set_min_size(width: int, height: int) -> None:
        """
        set the minimum size
        
        Set a minimum size for the window.
        
        The client can specify a minimum size so that the compositor does
        not try to configure the window below this size.
        
        The width and height arguments are in window geometry coordinates.
        See xdg_surface.set_window_geometry.
        
        Values set in this way are double-buffered, see wl_surface.commit.
        
        The compositor can use this information to allow or disallow
        different states like maximize or fullscreen and draw accurate
        animations.
        
        Similarly, a tiling window manager may use this information to
        place and resize client windows in a more effective way.
        
        The client should not rely on the compositor to obey the minimum
        size. The compositor may decide to ignore the values set by the
        client and request a smaller size.
        
        If never set, or a value of zero in the request, means that the
        client has no expected minimum size in the given dimension.
        As a result, a client wishing to reset the minimum size
        to an unspecified state can use zero for width and height in the
        request.
        
        Requesting a minimum size to be larger than the maximum size of
        a surface is illegal and will result in an invalid_size error.
        
        The width and height must be greater than or equal to zero. Using
        strictly negative values for width and height will result in a
        invalid_size error.
        """
        ...

    # opcode 9
    @staticmethod
    def set_maximized() -> None:
        """
        maximize the window
        
        Maximize the surface.
        
        After requesting that the surface should be maximized, the compositor
        will respond by emitting a configure event. Whether this configure
        actually sets the window maximized is subject to compositor policies.
        The client must then update its content, drawing in the configured
        state. The client must also acknowledge the configure when committing
        the new content (see ack_configure).
        
        It is up to the compositor to decide how and where to maximize the
        surface, for example which output and what region of the screen should
        be used.
        
        If the surface was already maximized, the compositor will still emit
        a configure event with the "maximized" state.
        
        If the surface is in a fullscreen state, this request has no direct
        effect. It may alter the state the surface is returned to when
        unmaximized unless overridden by the compositor.
        """
        ...

    # opcode 10
    @staticmethod
    def unset_maximized() -> None:
        """
        unmaximize the window
        
        Unmaximize the surface.
        
        After requesting that the surface should be unmaximized, the compositor
        will respond by emitting a configure event. Whether this actually
        un-maximizes the window is subject to compositor policies.
        If available and applicable, the compositor will include the window
        geometry dimensions the window had prior to being maximized in the
        configure event. The client must then update its content, drawing it in
        the configured state. The client must also acknowledge the configure
        when committing the new content (see ack_configure).
        
        It is up to the compositor to position the surface after it was
        unmaximized; usually the position the surface had before maximizing, if
        applicable.
        
        If the surface was already not maximized, the compositor will still
        emit a configure event without the "maximized" state.
        
        If the surface is in a fullscreen state, this request has no direct
        effect. It may alter the state the surface is returned to when
        unmaximized unless overridden by the compositor.
        """
        ...

    # opcode 11
    @staticmethod
    def set_fullscreen(output: object) -> None:
        """
        set the window as fullscreen on an output
        
        Make the surface fullscreen.
        
        After requesting that the surface should be fullscreened, the
        compositor will respond by emitting a configure event. Whether the
        client is actually put into a fullscreen state is subject to compositor
        policies. The client must also acknowledge the configure when
        committing the new content (see ack_configure).
        
        The output passed by the request indicates the client's preference as
        to which display it should be set fullscreen on. If this value is NULL,
        it's up to the compositor to choose which display will be used to map
        this surface.
        
        If the surface doesn't cover the whole output, the compositor will
        position the surface in the center of the output and compensate with
        with border fill covering the rest of the output. The content of the
        border fill is undefined, but should be assumed to be in some way that
        attempts to blend into the surrounding area (e.g. solid black).
        
        If the fullscreened surface is not opaque, the compositor must make
        sure that other screen content not part of the same surface tree (made
        up of subsurfaces, popups or similarly coupled surfaces) are not
        visible below the fullscreened surface.
        """
        ...

    # opcode 12
    @staticmethod
    def unset_fullscreen() -> None:
        """
        unset the window as fullscreen
        
        Make the surface no longer fullscreen.
        
        After requesting that the surface should be unfullscreened, the
        compositor will respond by emitting a configure event.
        Whether this actually removes the fullscreen state of the client is
        subject to compositor policies.
        
        Making a surface unfullscreen sets states for the surface based on the following:
        * the state(s) it may have had before becoming fullscreen
        * any state(s) decided by the compositor
        * any state(s) requested by the client while the surface was fullscreen
        
        The compositor may include the previous window geometry dimensions in
        the configure event, if applicable.
        
        The client must also acknowledge the configure when committing the new
        content (see ack_configure).
        """
        ...

    # opcode 13
    @staticmethod
    def set_minimized() -> None:
        """
        set the window as minimized
        
        Request that the compositor minimize your surface. There is no
        way to know if the surface is currently minimized, nor is there
        any way to unset minimization on this surface.
        
        If you are looking to throttle redrawing when minimized, please
        instead use the wl_surface.frame event for this, as this will
        also work with live previews on windows in Alt-Tab, Expose or
        similar compositor features.
        """
        ...

    class events:
        # opcode 0
        @staticmethod
        def configure(width: int, height: int, states: array) -> None:
            """
            suggest a surface change
            
            This configure event asks the client to resize its toplevel surface or
            to change its state. The configured state should not be applied
            immediately. See xdg_surface.configure for details.
            
            The width and height arguments specify a hint to the window
            about how its surface should be resized in window geometry
            coordinates. See set_window_geometry.
            
            If the width or height arguments are zero, it means the client
            should decide its own window dimension. This may happen when the
            compositor needs to configure the state of the surface but doesn't
            have any information about any previous or expected dimension.
            
            The states listed in the event specify how the width/height
            arguments should be interpreted, and possibly how it should be
            drawn.
            
            Clients must send an ack_configure in response to this event. See
            xdg_surface.configure and xdg_surface.ack_configure for details.
            """
            ...

        # opcode 1
        @staticmethod
        def close() -> None:
            """
            surface wants to be closed
            
            The close event is sent by the compositor when the user
            wants the surface to be closed. This should be equivalent to
            the user clicking the close button in client-side decorations,
            if your application has any.
            
            This is only a request that the user intends to close the
            window. The client may choose to ignore this request, or show
            a dialog to ask the user to save their data, etc.
            """
            ...

        # opcode 2
        @staticmethod
        def configure_bounds(width: int, height: int) -> None:
            """
            recommended window geometry bounds
            
            The configure_bounds event may be sent prior to a xdg_toplevel.configure
            event to communicate the bounds a window geometry size is recommended
            to constrain to.
            
            The passed width and height are in surface coordinate space. If width
            and height are 0, it means bounds is unknown and equivalent to as if no
            configure_bounds event was ever sent for this surface.
            
            The bounds can for example correspond to the size of a monitor excluding
            any panels or other shell components, so that a surface isn't created in
            a way that it cannot fit.
            
            The bounds may change at any point, and in such a case, a new
            xdg_toplevel.configure_bounds will be sent, followed by
            xdg_toplevel.configure and xdg_surface.configure.
            """
            ...

        # opcode 3
        @staticmethod
        def wm_capabilities(capabilities: array) -> None:
            """
            compositor capabilities
            
            This event advertises the capabilities supported by the compositor. If
            a capability isn't supported, clients should hide or disable the UI
            elements that expose this functionality. For instance, if the
            compositor doesn't advertise support for minimized toplevels, a button
            triggering the set_minimized request should not be displayed.
            
            The compositor will ignore requests it doesn't support. For instance,
            a compositor which doesn't advertise support for minimized will ignore
            set_minimized requests.
            
            Compositors must send this event once before the first
            xdg_surface.configure event. When the capabilities change, compositors
            must send this event again and then send an xdg_surface.configure
            event.
            
            The configured state should not be applied immediately. See
            xdg_surface.configure for details.
            
            The capabilities are sent as an array of 32-bit unsigned integers in
            native endianness.
            """
            ...

class xdg_popup:
    object_id = 0

    # opcode 0
    @staticmethod
    def destroy() -> None:
        """
        remove xdg_popup interface
        
        This destroys the popup. Explicitly destroying the xdg_popup
        object will also dismiss the popup, and unmap the surface.
        
        If this xdg_popup is not the "topmost" popup, the
        xdg_wm_base.not_the_topmost_popup protocol error will be sent.
        """
        ...

    # opcode 1
    @staticmethod
    def grab(seat: object, serial: uint) -> None:
        """
        make the popup take an explicit grab
        
        This request makes the created popup take an explicit grab. An explicit
        grab will be dismissed when the user dismisses the popup, or when the
        client destroys the xdg_popup. This can be done by the user clicking
        outside the surface, using the keyboard, or even locking the screen
        through closing the lid or a timeout.
        
        If the compositor denies the grab, the popup will be immediately
        dismissed.
        
        This request must be used in response to some sort of user action like a
        button press, key press, or touch down event. The serial number of the
        event should be passed as 'serial'.
        
        The parent of a grabbing popup must either be an xdg_toplevel surface or
        another xdg_popup with an explicit grab. If the parent is another
        xdg_popup it means that the popups are nested, with this popup now being
        the topmost popup.
        
        Nested popups must be destroyed in the reverse order they were created
        in, e.g. the only popup you are allowed to destroy at all times is the
        topmost one.
        
        When compositors choose to dismiss a popup, they may dismiss every
        nested grabbing popup as well. When a compositor dismisses popups, it
        will follow the same dismissing order as required from the client.
        
        If the topmost grabbing popup is destroyed, the grab will be returned to
        the parent of the popup, if that parent previously had an explicit grab.
        
        If the parent is a grabbing popup which has already been dismissed, this
        popup will be immediately dismissed. If the parent is a popup that did
        not take an explicit grab, an error will be raised.
        
        During a popup grab, the client owning the grab will receive pointer
        and touch events for all their surfaces as normal (similar to an
        "owner-events" grab in X11 parlance), while the top most grabbing popup
        will always have keyboard focus.
        """
        ...

    # opcode 2
    @staticmethod
    def reposition(positioner: object, token: uint) -> None:
        """
        recalculate the popup's location
        
        Reposition an already-mapped popup. The popup will be placed given the
        details in the passed xdg_positioner object, and a
        xdg_popup.repositioned followed by xdg_popup.configure and
        xdg_surface.configure will be emitted in response. Any parameters set
        by the previous positioner will be discarded.
        
        The passed token will be sent in the corresponding
        xdg_popup.repositioned event. The new popup position will not take
        effect until the corresponding configure event is acknowledged by the
        client. See xdg_popup.repositioned for details. The token itself is
        opaque, and has no other special meaning.
        
        If multiple reposition requests are sent, the compositor may skip all
        but the last one.
        
        If the popup is repositioned in response to a configure event for its
        parent, the client should send an xdg_positioner.set_parent_configure
        and possibly an xdg_positioner.set_parent_size request to allow the
        compositor to properly constrain the popup.
        
        If the popup is repositioned together with a parent that is being
        resized, but not in response to a configure event, the client should
        send an xdg_positioner.set_parent_size request.
        """
        ...

    class events:
        # opcode 0
        @staticmethod
        def configure(x: int, y: int, width: int, height: int) -> None:
            """
            configure the popup surface
            
            This event asks the popup surface to configure itself given the
            configuration. The configured state should not be applied immediately.
            See xdg_surface.configure for details.
            
            The x and y arguments represent the position the popup was placed at
            given the xdg_positioner rule, relative to the upper left corner of the
            window geometry of the parent surface.
            
            For version 2 or older, the configure event for an xdg_popup is only
            ever sent once for the initial configuration. Starting with version 3,
            it may be sent again if the popup is setup with an xdg_positioner with
            set_reactive requested, or in response to xdg_popup.reposition requests.
            """
            ...

        # opcode 1
        @staticmethod
        def popup_done() -> None:
            """
            popup interaction is done
            
            The popup_done event is sent out when a popup is dismissed by the
            compositor. The client should destroy the xdg_popup object at this
            point.
            """
            ...

        # opcode 2
        @staticmethod
        def repositioned(token: uint) -> None:
            """
            signal the completion of a repositioned request
            
            The repositioned event is sent as part of a popup configuration
            sequence, together with xdg_popup.configure and lastly
            xdg_surface.configure to notify the completion of a reposition request.
            
            The repositioned event is to notify about the completion of a
            xdg_popup.reposition request. The token argument is the token passed
            in the xdg_popup.reposition request.
            
            Immediately after this event is emitted, xdg_popup.configure and
            xdg_surface.configure will be sent with the updated size and position,
            as well as a new configure serial.
            
            The client should optionally update the content of the popup, but must
            acknowledge the new popup configuration for the new position to take
            effect. See xdg_surface.ack_configure for details.
            """
            ...

