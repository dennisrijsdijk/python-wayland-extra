# Copyright (c) 2024 Graham R King
#
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions:
#
# The above copyright notice and this permission notice (including the
# next paragraph) shall be included in all copies or substantial
# portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
# BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
# ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.


from copy import deepcopy


class TypeHinter:
    def create_type_hinting(self, structure, path):
        file_name = f"{path}/__init__.pyi"

        self.headers = [
            "# DO NOT EDIT this file, it is automatically generated.",
            "# ",
            "# This file is only used as a code completion helper",
            "# for editors, it is not used at runtime.",
            "",
            "from typing import TypeAlias, Annotated",
            "from enum import Enum, IntFlag",
            "new_id: TypeAlias = int",
            "object: TypeAlias = int",
            "uint: TypeAlias = int",
            "string: TypeAlias = str",
            "fd: TypeAlias = int",
            "array: TypeAlias = list",
            "fixed: TypeAlias = float",
            "",
        ]
        self.headers = [x + "\n" for x in self.headers]
        class_definitions = []

        # Iterate the entire wayland protocol structure
        for class_name, details in structure.items():
            # Describe each class
            class_declaration = f"class {class_name}:\n"
            iface_desc = details["description"]
            class_declaration += self.indent(iface_desc, 4, comment=True)
            class_declaration += (
                f"    object_id = 0\n    version = {details['version']}\n\n"
            )

            # Add requests and events and enums
            class_body = ""
            class_body += self.process_members(class_name, details.get("requests", []))
            class_events_declaration = "    class events:\n"
            class_events = self.process_members(
                class_name, details.get("events", []), events=True
            )
            class_enums = self.process_enums(details.get("enums", []))

            if not class_events:
                class_events_declaration = ""  # no events? don't create events class
            else:
                class_body += class_events_declaration + class_events

            class_definitions.append(class_declaration + class_enums + class_body)

        class_definitions = self.headers + class_definitions

        with open(file_name, "w", encoding="utf-8") as outfile:
            for class_def in class_definitions:
                outfile.write(class_def)

    def process_members(self, class_name, members, *, events=False):
        if events:
            indent_declaration = 8
            indent_body = 12
        else:
            indent_declaration = 4
            indent_body = 8

        pad = " " * indent_declaration
        pad_body = " " * indent_body

        definitions = ""

        for member in members:
            # Check if this creates a new object of a known type
            original_args = deepcopy(member["args"])
            new_args = []
            return_type = None

            for arg in original_args:
                # new_id arg types are converted to their object types if possible
                if arg["type"] == "new_id":
                    interface = arg.get("interface")
                    if interface and not events:
                        # we don't need new_id in requests if we know the object type
                        return_type = interface
                        continue
                    if interface and events:
                        # use the object type as the arg type instead of new_id
                        arg["type"] = interface

                # Change enum types into the specific type of enum
                elif arg.get("enum"):
                    arg["type"] = f"{class_name}.{arg['enum']}"

                new_args.append(arg)

            signature = f"# opcode {member['opcode']}\n"
            signature += f"{pad}@staticmethod\n"
            signature += f"{pad}def {member['name']}("
            signature += ", ".join(f"{arg['name']}: {arg['type']}" for arg in new_args)
            if return_type:
                signature += f") -> {return_type}:\n"
            else:
                signature += ") -> None:\n"

            signature += self.indent(member["description"], indent_body)
            signature += f"{pad_body}...\n\n"
            definitions += f"{pad}{signature}"

            if not definitions:
                definitions = f"{pad_body}..."

        return definitions

    def process_enums(self, members):
        indent_declaration = 4
        indent_body = 8

        pad = " " * indent_declaration
        pad_body = " " * indent_body

        definitions = ""

        for member in members:
            enum_name = member.get("name")
            enum_type = "IntFlag" if member.get("bitfield") else "Enum"
            enum_args = member.get("args")

            signature = f"{pad}class {enum_name}({enum_type}):\n"
            for arg in enum_args:
                value_name = arg["name"]
                try:
                    _ = int(value_name)
                    value_name = f"{enum_name}_{value_name}"
                except ValueError:
                    pass  # ok
                signature += f"{pad_body}{value_name}: int\n"

            definitions += f"{signature}\n"

            if not definitions:
                definitions = f"{pad_body}..."

        return definitions

    @classmethod
    def indent(cls, input_string, indent_columns, *, comment=True):
        indent = " " * indent_columns
        indented_string = "\n".join(indent + line for line in input_string.splitlines())
        if comment:
            indented_string = f'{indent}"""\n{indented_string}\n{indent}"""\n'
        return indented_string
